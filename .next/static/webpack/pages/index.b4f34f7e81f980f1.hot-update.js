"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./node_modules/bech32/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bech32/dist/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n    const x = ALPHABET.charAt(z);\n    ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            return 'Invalid prefix (' + prefix + ')';\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            return 'Excess padding';\n        if ((value << (outBits - bits)) & maxV)\n            return 'Non-zero padding';\n    }\n    return result;\n}\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n}\nfunction fromWords(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n    throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n    let ENCODING_CONST;\n    if (encoding === 'bech32') {\n        ENCODING_CONST = 1;\n    }\n    else {\n        ENCODING_CONST = 0x2bc830a3;\n    }\n    function encode(prefix, words, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (prefix.length + 7 + words.length > LIMIT)\n            throw new TypeError('Exceeds length limit');\n        prefix = prefix.toLowerCase();\n        // determine chk mod\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            throw new Error(chk);\n        let result = prefix + '1';\n        for (let i = 0; i < words.length; ++i) {\n            const x = words[i];\n            if (x >> 5 !== 0)\n                throw new Error('Non 5-bit word');\n            chk = polymodStep(chk) ^ x;\n            result += ALPHABET.charAt(x);\n        }\n        for (let i = 0; i < 6; ++i) {\n            chk = polymodStep(chk);\n        }\n        chk ^= ENCODING_CONST;\n        for (let i = 0; i < 6; ++i) {\n            const v = (chk >> ((5 - i) * 5)) & 0x1f;\n            result += ALPHABET.charAt(v);\n        }\n        return result;\n    }\n    function __decode(str, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (str.length < 8)\n            return str + ' too short';\n        if (str.length > LIMIT)\n            return 'Exceeds length limit';\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        const uppered = str.toUpperCase();\n        if (str !== lowered && str !== uppered)\n            return 'Mixed-case string ' + str;\n        str = lowered;\n        const split = str.lastIndexOf('1');\n        if (split === -1)\n            return 'No separator character for ' + str;\n        if (split === 0)\n            return 'Missing prefix for ' + str;\n        const prefix = str.slice(0, split);\n        const wordChars = str.slice(split + 1);\n        if (wordChars.length < 6)\n            return 'Data too short';\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            return chk;\n        const words = [];\n        for (let i = 0; i < wordChars.length; ++i) {\n            const c = wordChars.charAt(i);\n            const v = ALPHABET_MAP[c];\n            if (v === undefined)\n                return 'Unknown character ' + c;\n            chk = polymodStep(chk) ^ v;\n            // not in the checksum?\n            if (i + 6 >= wordChars.length)\n                continue;\n            words.push(v);\n        }\n        if (chk !== ENCODING_CONST)\n            return 'Invalid checksum for ' + str;\n        return { prefix, words };\n    }\n    function decodeUnsafe(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n    }\n    function decode(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n        throw new Error(res);\n    }\n    return {\n        decodeUnsafe,\n        decode,\n        encode,\n        toWords,\n        fromWordsUnsafe,\n        fromWords,\n    };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmVjaDMyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGNBQWM7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iZWNoMzIvZGlzdC9pbmRleC5qcz84YjI0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmVjaDMybSA9IGV4cG9ydHMuYmVjaDMyID0gdm9pZCAwO1xuY29uc3QgQUxQSEFCRVQgPSAncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnO1xuY29uc3QgQUxQSEFCRVRfTUFQID0ge307XG5mb3IgKGxldCB6ID0gMDsgeiA8IEFMUEhBQkVULmxlbmd0aDsgeisrKSB7XG4gICAgY29uc3QgeCA9IEFMUEhBQkVULmNoYXJBdCh6KTtcbiAgICBBTFBIQUJFVF9NQVBbeF0gPSB6O1xufVxuZnVuY3Rpb24gcG9seW1vZFN0ZXAocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICByZXR1cm4gKCgocHJlICYgMHgxZmZmZmZmKSA8PCA1KSBeXG4gICAgICAgICgtKChiID4+IDApICYgMSkgJiAweDNiNmE1N2IyKSBeXG4gICAgICAgICgtKChiID4+IDEpICYgMSkgJiAweDI2NTA4ZTZkKSBeXG4gICAgICAgICgtKChiID4+IDIpICYgMSkgJiAweDFlYTExOWZhKSBeXG4gICAgICAgICgtKChiID4+IDMpICYgMSkgJiAweDNkNDIzM2RkKSBeXG4gICAgICAgICgtKChiID4+IDQpICYgMSkgJiAweDJhMTQ2MmIzKSk7XG59XG5mdW5jdGlvbiBwcmVmaXhDaGsocHJlZml4KSB7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgcHJlZml4ICgnICsgcHJlZml4ICsgJyknO1xuICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IHBvbHltb2RTdGVwKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdiA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKHYgJiAweDFmKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGNvbnZlcnQoZGF0YSwgaW5CaXRzLCBvdXRCaXRzLCBwYWQpIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGxldCBiaXRzID0gMDtcbiAgICBjb25zdCBtYXhWID0gKDEgPDwgb3V0Qml0cykgLSAxO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBpbkJpdHMpIHwgZGF0YVtpXTtcbiAgICAgICAgYml0cyArPSBpbkJpdHM7XG4gICAgICAgIHdoaWxlIChiaXRzID49IG91dEJpdHMpIHtcbiAgICAgICAgICAgIGJpdHMgLT0gb3V0Qml0cztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCh2YWx1ZSA+PiBiaXRzKSAmIG1heFYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYWQpIHtcbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJpdHMgPj0gaW5CaXRzKVxuICAgICAgICAgICAgcmV0dXJuICdFeGNlc3MgcGFkZGluZyc7XG4gICAgICAgIGlmICgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKVxuICAgICAgICAgICAgcmV0dXJuICdOb24temVybyBwYWRkaW5nJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvV29yZHMoYnl0ZXMpIHtcbiAgICByZXR1cm4gY29udmVydChieXRlcywgOCwgNSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmcm9tV29yZHNVbnNhZmUod29yZHMpIHtcbiAgICBjb25zdCByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSlcbiAgICAgICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZyb21Xb3Jkcyh3b3Jkcykge1xuICAgIGNvbnN0IHJlcyA9IGNvbnZlcnQod29yZHMsIDUsIDgsIGZhbHNlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBFcnJvcihyZXMpO1xufVxuZnVuY3Rpb24gZ2V0TGlicmFyeUZyb21FbmNvZGluZyhlbmNvZGluZykge1xuICAgIGxldCBFTkNPRElOR19DT05TVDtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiZWNoMzInKSB7XG4gICAgICAgIEVOQ09ESU5HX0NPTlNUID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIEVOQ09ESU5HX0NPTlNUID0gMHgyYmM4MzBhMztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIExJTUlUKSB7XG4gICAgICAgIExJTUlUID0gTElNSVQgfHwgOTA7XG4gICAgICAgIGlmIChwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aCA+IExJTUlUKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjZWVkcyBsZW5ndGggbGltaXQnKTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIGRldGVybWluZSBjaGsgbW9kXG4gICAgICAgIGxldCBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNoayk7XG4gICAgICAgIGxldCByZXN1bHQgPSBwcmVmaXggKyAnMSc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB3b3Jkc1tpXTtcbiAgICAgICAgICAgIGlmICh4ID4+IDUgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24gNS1iaXQgd29yZCcpO1xuICAgICAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIHg7XG4gICAgICAgICAgICByZXN1bHQgKz0gQUxQSEFCRVQuY2hhckF0KHgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuICAgICAgICB9XG4gICAgICAgIGNoayBePSBFTkNPRElOR19DT05TVDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoY2hrID4+ICgoNSAtIGkpICogNSkpICYgMHgxZjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX19kZWNvZGUoc3RyLCBMSU1JVCkge1xuICAgICAgICBMSU1JVCA9IExJTUlUIHx8IDkwO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICByZXR1cm4gc3RyICsgJyB0b28gc2hvcnQnO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IExJTUlUKVxuICAgICAgICAgICAgcmV0dXJuICdFeGNlZWRzIGxlbmd0aCBsaW1pdCc7XG4gICAgICAgIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB1cHBlcmVkID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSB1cHBlcmVkKVxuICAgICAgICAgICAgcmV0dXJuICdNaXhlZC1jYXNlIHN0cmluZyAnICsgc3RyO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzcGxpdCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc3BsaXQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuICdObyBzZXBhcmF0b3IgY2hhcmFjdGVyIGZvciAnICsgc3RyO1xuICAgICAgICBpZiAoc3BsaXQgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gJ01pc3NpbmcgcHJlZml4IGZvciAnICsgc3RyO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc3BsaXQpO1xuICAgICAgICBjb25zdCB3b3JkQ2hhcnMgPSBzdHIuc2xpY2Uoc3BsaXQgKyAxKTtcbiAgICAgICAgaWYgKHdvcmRDaGFycy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgcmV0dXJuICdEYXRhIHRvbyBzaG9ydCc7XG4gICAgICAgIGxldCBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGNoaztcbiAgICAgICAgY29uc3Qgd29yZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB3b3JkQ2hhcnMuY2hhckF0KGkpO1xuICAgICAgICAgICAgY29uc3QgdiA9IEFMUEhBQkVUX01BUFtjXTtcbiAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdVbmtub3duIGNoYXJhY3RlciAnICsgYztcbiAgICAgICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB2O1xuICAgICAgICAgICAgLy8gbm90IGluIHRoZSBjaGVja3N1bT9cbiAgICAgICAgICAgIGlmIChpICsgNiA+PSB3b3JkQ2hhcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgd29yZHMucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hrICE9PSBFTkNPRElOR19DT05TVClcbiAgICAgICAgICAgIHJldHVybiAnSW52YWxpZCBjaGVja3N1bSBmb3IgJyArIHN0cjtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUoc3RyLCBMSU1JVCkge1xuICAgICAgICBjb25zdCByZXMgPSBfX2RlY29kZShzdHIsIExJTUlUKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gX19kZWNvZGUoc3RyLCBMSU1JVCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGRlY29kZSxcbiAgICAgICAgZW5jb2RlLFxuICAgICAgICB0b1dvcmRzLFxuICAgICAgICBmcm9tV29yZHNVbnNhZmUsXG4gICAgICAgIGZyb21Xb3JkcyxcbiAgICB9O1xufVxuZXhwb3J0cy5iZWNoMzIgPSBnZXRMaWJyYXJ5RnJvbUVuY29kaW5nKCdiZWNoMzInKTtcbmV4cG9ydHMuYmVjaDMybSA9IGdldExpYnJhcnlGcm9tRW5jb2RpbmcoJ2JlY2gzMm0nKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bech32/dist/index.js\n"));

/***/ }),

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _noble_secp256k1__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/secp256k1 */ \"./node_modules/@noble/secp256k1/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bech32 */ \"./node_modules/bech32/dist/index.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n// Constants for library structure\nconst VOLUMES_PER_SHELF = 32;\nconst SHELVES_PER_WALL = 5;\nconst WALLS_PER_HEX = 4;\nconst PAGES_PER_VOLUME = 410;\nconst WALLS = BigInt(WALLS_PER_HEX);\n_c = WALLS;\nconst SHELVES = BigInt(SHELVES_PER_WALL);\n_c1 = SHELVES;\nconst VOLUMES = BigInt(VOLUMES_PER_SHELF);\n_c2 = VOLUMES;\nconst PAGES = BigInt(PAGES_PER_VOLUME);\n_c3 = PAGES;\nconst MAX_KEY = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"); // 2^256 - 1\nconst N = MAX_KEY + 1n;\n// Feistel network parameters\nconst FEISTEL_ROUNDS = 10;\nconst FEISTEL_KEYS = [\n    BigInt(\"314159265358979323846264338327950288419716939937510\"),\n    BigInt(\"271828182845904523536028747135266249775724709369995\"),\n    BigInt(\"141421356237309504880168872420969807856967187537694\"),\n    BigInt(\"161803398874989484820458683436563811772030917980576\"),\n    BigInt(\"173205080756887729352744634150587236694280525910297\"),\n    BigInt(\"223606797749978969640917366873127623544061835961153\"),\n    BigInt(\"112358132134558914423337761098715972584418167651094\"),\n    BigInt(\"271828182845904523536028747135266249775724709369995\"),\n    BigInt(\"314159265358979323846264338327950288419716939937510\"),\n    BigInt(\"161803398874989484820458683436563811772030917980576\")\n];\n// Arbitrary-precision base36 to BigInt\nfunction base36ToBigInt(str) {\n    let result = 0n;\n    for(let i = 0; i < str.length; i++){\n        const c = str[i].toLowerCase();\n        let v;\n        if (c >= \"0\" && c <= \"9\") v = c.charCodeAt(0) - 48;\n        else if (c >= \"a\" && c <= \"z\") v = c.charCodeAt(0) - 87;\n        else continue;\n        result = result * 36n + BigInt(v);\n    }\n    return result;\n}\nfunction bigIntToBase36(num) {\n    if (num === 0n) return \"0\";\n    let result = \"\";\n    let n = num;\n    while(n > 0n){\n        const rem = n % 36n;\n        result = rem.toString(36) + result;\n        n /= 36n;\n    }\n    return result;\n}\nfunction locationToIndex(hex, wall, shelf, volume, page) {\n    // Convert hex string to BigInt\n    const hexNum = base36ToBigInt(hex);\n    let idx = (((hexNum * WALLS + BigInt(wall)) * SHELVES + BigInt(shelf)) * VOLUMES + BigInt(volume)) * PAGES + BigInt(page);\n    return idx % N; // Wrap to valid keyspace\n}\nfunction indexToLocation(index) {\n    let idx = index % N; // Wrap to valid keyspace\n    let remainder = idx;\n    const page = remainder % PAGES;\n    remainder /= PAGES;\n    const volume = remainder % VOLUMES;\n    remainder /= VOLUMES;\n    const shelf = remainder % SHELVES;\n    remainder /= SHELVES;\n    const wall = remainder % WALLS;\n    remainder /= WALLS;\n    const hex = remainder;\n    return {\n        hex: bigIntToBase36(hex),\n        wall: Number(wall),\n        shelf: Number(shelf),\n        volume: Number(volume),\n        page: Number(page)\n    };\n}\n// Improved Feistel round function for better bit mixing\nfunction feistelF(right, key) {\n    // Mix using both multiplication and xor, then mod 2^128\n    return ((right ^ key) * (key | 1n) + (right << 13n) + (right >> 17n)) % (1n << 128n);\n}\nfunction feistelEncrypt(index) {\n    let L = index >> 128n;\n    let R = index & (1n << 128n) - 1n;\n    for(let i = 0; i < FEISTEL_ROUNDS; ++i){\n        const newL = R;\n        const newR = L ^ feistelF(R, FEISTEL_KEYS[i]);\n        L = newL;\n        R = newR;\n    }\n    return L << 128n | R;\n}\nfunction feistelDecrypt(key) {\n    let L = key >> 128n;\n    let R = key & (1n << 128n) - 1n;\n    for(let i = FEISTEL_ROUNDS - 1; i >= 0; --i){\n        const newR = L;\n        const newL = R ^ feistelF(L, FEISTEL_KEYS[i]);\n        L = newL;\n        R = newR;\n    }\n    return L << 128n | R;\n}\nfunction locationToKey(hex, wall, shelf, volume, page) {\n    const index = locationToIndex(hex, wall, shelf, volume, page);\n    return feistelEncrypt(index);\n}\nfunction keyToLocation(key) {\n    const index = feistelDecrypt(key);\n    return indexToLocation(index);\n}\nfunction pubkeyToP2WPKH(pubkeyHex) {\n    // 1. Hash160 (SHA256 then RIPEMD160)\n    const pubkeyBytes = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_3__.utils.hexToBytes(pubkeyHex);\n    const sha256 = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_3__.utils.sha256(pubkeyBytes);\n    const ripemd160 = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_3__.utils.ripemd160(sha256);\n    // 2. Witness version 0 + hash160\n    const words = bech32__WEBPACK_IMPORTED_MODULE_2__.bech32.toWords(ripemd160);\n    words.unshift(0x00);\n    // 3. Encode as bech32 (bc1...)\n    return bech32__WEBPACK_IMPORTED_MODULE_2__.bech32.encode(\"bc\", words);\n}\nfunction Home() {\n    _s();\n    // State for navigation\n    const [hex, setHex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"0\");\n    const [wall, setWall] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [shelf, setShelf] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [volume, setVolume] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [page, setPage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [keyInput, setKeyInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [locationResult, setLocationResult] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [overflow, setOverflow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Compute index and overflow\n    const hexNum = base36ToBigInt(hex);\n    let idx = (((hexNum * WALLS + BigInt(wall)) * SHELVES + BigInt(shelf)) * VOLUMES + BigInt(volume)) * PAGES + BigInt(page);\n    const didOverflow = idx >= N;\n    const key = locationToKey(hex, wall, shelf, volume, page);\n    // Clamp navigation\n    function clamp(val, min, max) {\n        return Math.max(min, Math.min(max, val));\n    }\n    function handleKeySearch() {\n        try {\n            let k = keyInput.startsWith(\"0x\") ? BigInt(keyInput) : BigInt(\"0x\" + keyInput);\n            setLocationResult(keyToLocation(k));\n        } catch (e) {\n            setLocationResult(null);\n        }\n    }\n    function handleGoToLocation() {\n        if (locationResult) {\n            setHex(locationResult.hex);\n            setWall(locationResult.wall);\n            setShelf(locationResult.shelf);\n            setVolume(locationResult.volume);\n            setPage(locationResult.page);\n            setLocationResult(null);\n            setKeyInput(\"\");\n        }\n    }\n    function randomString(length) {\n        const chars = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n        let result = \"\";\n        for(let i = 0; i < length; i++){\n            result += chars[Math.floor(Math.random() * chars.length)];\n        }\n        return result;\n    }\n    function handleRandom() {\n        // Pick random valid values for all fields\n        setHex(randomString(Math.floor(Math.random() * 8) + 2)); // 2-9 chars\n        setWall(Math.floor(Math.random() * WALLS_PER_HEX));\n        setShelf(Math.floor(Math.random() * SHELVES_PER_WALL));\n        setVolume(Math.floor(Math.random() * VOLUMES_PER_SHELF));\n        setPage(Math.floor(Math.random() * PAGES_PER_VOLUME));\n        setLocationResult(null);\n        setKeyInput(\"\");\n    }\n    // Compute public key and address\n    let pubkeyHex = \"\";\n    let bech32Addr = \"\";\n    try {\n        pubkeyHex = (0,_noble_secp256k1__WEBPACK_IMPORTED_MODULE_3__.getPublicKey)(key.toString(16).padStart(64, \"0\"), true); // compressed\n        bech32Addr = pubkeyToP2WPKH(pubkeyHex);\n    } catch (e) {}\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            padding: 24,\n            fontFamily: \"monospace\",\n            maxWidth: 700,\n            margin: \"auto\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                children: \"Library of Private Keys\"\n            }, void 0, false, {\n                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                lineNumber: 212,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginBottom: 16\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \"Hexagon:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 214,\n                        columnNumber: 9\n                    }, this),\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"text\",\n                        value: hex,\n                        onChange: (e)=>setHex(e.target.value.replace(/[^a-zA-Z0-9]/g, \"\")),\n                        style: {\n                            width: 90\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 214,\n                        columnNumber: 25\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \" Wall:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 215,\n                        columnNumber: 9\n                    }, this),\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"number\",\n                        min: 0,\n                        max: WALLS_PER_HEX - 1,\n                        value: wall,\n                        onChange: (e)=>setWall(clamp(Number(e.target.value), 0, WALLS_PER_HEX - 1))\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 215,\n                        columnNumber: 23\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \" Shelf:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 216,\n                        columnNumber: 9\n                    }, this),\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"number\",\n                        min: 0,\n                        max: SHELVES_PER_WALL - 1,\n                        value: shelf,\n                        onChange: (e)=>setShelf(clamp(Number(e.target.value), 0, SHELVES_PER_WALL - 1))\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 216,\n                        columnNumber: 24\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \" Volume:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 217,\n                        columnNumber: 9\n                    }, this),\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"number\",\n                        min: 0,\n                        max: VOLUMES_PER_SHELF - 1,\n                        value: volume,\n                        onChange: (e)=>setVolume(clamp(Number(e.target.value), 0, VOLUMES_PER_SHELF - 1))\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 217,\n                        columnNumber: 25\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \" Page:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 218,\n                        columnNumber: 9\n                    }, this),\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"number\",\n                        min: 0,\n                        max: PAGES_PER_VOLUME - 1,\n                        value: page,\n                        onChange: (e)=>setPage(clamp(Number(e.target.value), 0, PAGES_PER_VOLUME - 1))\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 218,\n                        columnNumber: 23\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: handleRandom,\n                        style: {\n                            marginLeft: 16\n                        },\n                        children: \"Random\"\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 219,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                lineNumber: 213,\n                columnNumber: 7\n            }, this),\n            didOverflow && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    color: \"orange\",\n                    marginBottom: 8\n                },\n                children: \"Note: This location is outside the canonical keyspace and wraps around (periodic library).\"\n            }, void 0, false, {\n                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                lineNumber: 221,\n                columnNumber: 23\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    margin: \"24px 0\",\n                    background: \"#f4f4f4\",\n                    padding: 16,\n                    borderRadius: 8\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                            children: \"Private Key (hex):\"\n                        }, void 0, false, {\n                            fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                            lineNumber: 223,\n                            columnNumber: 14\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 223,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            fontSize: 18,\n                            wordBreak: \"break-all\",\n                            color: \"#333\"\n                        },\n                        children: \"0x\" + key.toString(16).padStart(64, \"0\")\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 224,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            marginTop: 16\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                            children: \"Public Key (hex, compressed):\"\n                        }, void 0, false, {\n                            fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                            lineNumber: 225,\n                            columnNumber: 40\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 225,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            fontSize: 15,\n                            wordBreak: \"break-all\",\n                            color: \"#222\"\n                        },\n                        children: pubkeyHex\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 226,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            marginTop: 16\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                            children: \"Bech32 Address (P2WPKH):\"\n                        }, void 0, false, {\n                            fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                            lineNumber: 227,\n                            columnNumber: 40\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 227,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            fontSize: 15,\n                            wordBreak: \"break-all\",\n                            color: \"#005a00\"\n                        },\n                        children: bech32Addr\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 228,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                lineNumber: 222,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    color: \"#888\",\n                    fontSize: 13\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            \"Location: Hexagon \",\n                            hex,\n                            \", Wall \",\n                            wall,\n                            \", Shelf \",\n                            shelf,\n                            \", Volume \",\n                            volume,\n                            \", Page \",\n                            page\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 231,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            \"Key Index: \",\n                            key.toString()\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 232,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                lineNumber: 230,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hr\", {\n                style: {\n                    margin: \"32px 0\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                lineNumber: 234,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \"Find location by key:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 236,\n                        columnNumber: 9\n                    }, this),\n                    \" \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"text\",\n                        placeholder: \"0x...\",\n                        value: keyInput,\n                        onChange: (e)=>setKeyInput(e.target.value),\n                        style: {\n                            width: 340\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 236,\n                        columnNumber: 38\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: handleKeySearch,\n                        style: {\n                            marginLeft: 8\n                        },\n                        children: \"Find Location\"\n                    }, void 0, false, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 237,\n                        columnNumber: 9\n                    }, this),\n                    locationResult && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            marginTop: 12,\n                            color: \"#444\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Hexagon: \",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                        children: locationResult.hex\n                                    }, void 0, false, {\n                                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                        lineNumber: 240,\n                                        columnNumber: 27\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                lineNumber: 240,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Wall: \",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                        children: locationResult.wall\n                                    }, void 0, false, {\n                                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                        lineNumber: 241,\n                                        columnNumber: 24\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                lineNumber: 241,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Shelf: \",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                        children: locationResult.shelf\n                                    }, void 0, false, {\n                                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                        lineNumber: 242,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                lineNumber: 242,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Volume: \",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                        children: locationResult.volume\n                                    }, void 0, false, {\n                                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                        lineNumber: 243,\n                                        columnNumber: 26\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                lineNumber: 243,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Page: \",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                        children: locationResult.page\n                                    }, void 0, false, {\n                                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                        lineNumber: 244,\n                                        columnNumber: 24\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                lineNumber: 244,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleGoToLocation,\n                                style: {\n                                    marginTop: 8\n                                },\n                                children: \"Go to Location\"\n                            }, void 0, false, {\n                                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                                lineNumber: 245,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                        lineNumber: 239,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n                lineNumber: 235,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/thisisthefoxe/git/btc-babel/pages/index.tsx\",\n        lineNumber: 211,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"uu4pq5jEqUkXzkgX/FQm+vaK9vo=\");\n_c4 = Home;\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"WALLS\");\n$RefreshReg$(_c1, \"SHELVES\");\n$RefreshReg$(_c2, \"VOLUMES\");\n$RefreshReg$(_c3, \"PAGES\");\n$RefreshReg$(_c4, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eEMsZ0NBQ0MsOERBQUNxQjt3QkFBSUMsT0FBTzs0QkFBRXdCLFdBQVc7NEJBQUlMLE9BQU87d0JBQU87OzBDQUN6Qyw4REFBQ3BCOztvQ0FBSTtrREFBUyw4REFBQ1E7a0RBQUc3QixlQUFleEMsR0FBRzs7Ozs7Ozs7Ozs7OzBDQUNwQyw4REFBQzZEOztvQ0FBSTtrREFBTSw4REFBQ1E7a0RBQUc3QixlQUFldkMsSUFBSTs7Ozs7Ozs7Ozs7OzBDQUNsQyw4REFBQzREOztvQ0FBSTtrREFBTyw4REFBQ1E7a0RBQUc3QixlQUFldEMsS0FBSzs7Ozs7Ozs7Ozs7OzBDQUNwQyw4REFBQzJEOztvQ0FBSTtrREFBUSw4REFBQ1E7a0RBQUc3QixlQUFlckMsTUFBTTs7Ozs7Ozs7Ozs7OzBDQUN0Qyw4REFBQzBEOztvQ0FBSTtrREFBTSw4REFBQ1E7a0RBQUc3QixlQUFlcEMsSUFBSTs7Ozs7Ozs7Ozs7OzBDQUNsQyw4REFBQzBFO2dDQUFPQyxTQUFTMUI7Z0NBQW9CUyxPQUFPO29DQUFFd0IsV0FBVztnQ0FBRTswQ0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTTFFO0dBaEh3QnREO01BQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL2luZGV4LnRzeD8wN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXRpbHMsIGdldFB1YmxpY0tleSB9IGZyb20gJ0Bub2JsZS9zZWNwMjU2azEnO1xuaW1wb3J0IHsgYmVjaDMyIH0gZnJvbSAnYmVjaDMyJztcblxuLy8gQ29uc3RhbnRzIGZvciBsaWJyYXJ5IHN0cnVjdHVyZVxuY29uc3QgVk9MVU1FU19QRVJfU0hFTEYgPSAzMjtcbmNvbnN0IFNIRUxWRVNfUEVSX1dBTEwgPSA1O1xuY29uc3QgV0FMTFNfUEVSX0hFWCA9IDQ7XG5jb25zdCBQQUdFU19QRVJfVk9MVU1FID0gNDEwO1xuXG5jb25zdCBXQUxMUyA9IEJpZ0ludChXQUxMU19QRVJfSEVYKTtcbmNvbnN0IFNIRUxWRVMgPSBCaWdJbnQoU0hFTFZFU19QRVJfV0FMTCk7XG5jb25zdCBWT0xVTUVTID0gQmlnSW50KFZPTFVNRVNfUEVSX1NIRUxGKTtcbmNvbnN0IFBBR0VTID0gQmlnSW50KFBBR0VTX1BFUl9WT0xVTUUpO1xuXG5jb25zdCBNQVhfS0VZID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnKTsgLy8gMl4yNTYgLSAxXG5jb25zdCBOID0gTUFYX0tFWSArIDFuO1xuXG4vLyBGZWlzdGVsIG5ldHdvcmsgcGFyYW1ldGVyc1xuY29uc3QgRkVJU1RFTF9ST1VORFMgPSAxMDtcbmNvbnN0IEZFSVNURUxfS0VZUyA9IFtcbiAgQmlnSW50KCczMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTAnKSxcbiAgQmlnSW50KCcyNzE4MjgxODI4NDU5MDQ1MjM1MzYwMjg3NDcxMzUyNjYyNDk3NzU3MjQ3MDkzNjk5OTUnKSxcbiAgQmlnSW50KCcxNDE0MjEzNTYyMzczMDk1MDQ4ODAxNjg4NzI0MjA5Njk4MDc4NTY5NjcxODc1Mzc2OTQnKSxcbiAgQmlnSW50KCcxNjE4MDMzOTg4NzQ5ODk0ODQ4MjA0NTg2ODM0MzY1NjM4MTE3NzIwMzA5MTc5ODA1NzYnKSxcbiAgQmlnSW50KCcxNzMyMDUwODA3NTY4ODc3MjkzNTI3NDQ2MzQxNTA1ODcyMzY2OTQyODA1MjU5MTAyOTcnKSxcbiAgQmlnSW50KCcyMjM2MDY3OTc3NDk5Nzg5Njk2NDA5MTczNjY4NzMxMjc2MjM1NDQwNjE4MzU5NjExNTMnKSxcbiAgQmlnSW50KCcxMTIzNTgxMzIxMzQ1NTg5MTQ0MjMzMzc3NjEwOTg3MTU5NzI1ODQ0MTgxNjc2NTEwOTQnKSxcbiAgQmlnSW50KCcyNzE4MjgxODI4NDU5MDQ1MjM1MzYwMjg3NDcxMzUyNjYyNDk3NzU3MjQ3MDkzNjk5OTUnKSxcbiAgQmlnSW50KCczMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTAnKSxcbiAgQmlnSW50KCcxNjE4MDMzOTg4NzQ5ODk0ODQ4MjA0NTg2ODM0MzY1NjM4MTE3NzIwMzA5MTc5ODA1NzYnKSxcbl07XG5cbi8vIEFyYml0cmFyeS1wcmVjaXNpb24gYmFzZTM2IHRvIEJpZ0ludFxuZnVuY3Rpb24gYmFzZTM2VG9CaWdJbnQoc3RyOiBzdHJpbmcpOiBiaWdpbnQge1xuICBsZXQgcmVzdWx0ID0gMG47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYyA9IHN0cltpXS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCB2O1xuICAgIGlmIChjID49ICcwJyAmJiBjIDw9ICc5JykgdiA9IGMuY2hhckNvZGVBdCgwKSAtIDQ4O1xuICAgIGVsc2UgaWYgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKSB2ID0gYy5jaGFyQ29kZUF0KDApIC0gODc7XG4gICAgZWxzZSBjb250aW51ZTtcbiAgICByZXN1bHQgPSByZXN1bHQgKiAzNm4gKyBCaWdJbnQodik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJpZ0ludFRvQmFzZTM2KG51bTogYmlnaW50KTogc3RyaW5nIHtcbiAgaWYgKG51bSA9PT0gMG4pIHJldHVybiAnMCc7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgbGV0IG4gPSBudW07XG4gIHdoaWxlIChuID4gMG4pIHtcbiAgICBjb25zdCByZW0gPSBuICUgMzZuO1xuICAgIHJlc3VsdCA9IHJlbS50b1N0cmluZygzNikgKyByZXN1bHQ7XG4gICAgbiAvPSAzNm47XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbG9jYXRpb25Ub0luZGV4KGhleDogc3RyaW5nLCB3YWxsOiBudW1iZXIsIHNoZWxmOiBudW1iZXIsIHZvbHVtZTogbnVtYmVyLCBwYWdlOiBudW1iZXIpOiBiaWdpbnQge1xuICAvLyBDb252ZXJ0IGhleCBzdHJpbmcgdG8gQmlnSW50XG4gIGNvbnN0IGhleE51bSA9IGJhc2UzNlRvQmlnSW50KGhleCk7XG4gIGxldCBpZHggPSAoKCgoaGV4TnVtICogV0FMTFMgKyBCaWdJbnQod2FsbCkpICogU0hFTFZFUyArIEJpZ0ludChzaGVsZikpICogVk9MVU1FUyArIEJpZ0ludCh2b2x1bWUpKSAqIFBBR0VTICsgQmlnSW50KHBhZ2UpKTtcbiAgcmV0dXJuIGlkeCAlIE47IC8vIFdyYXAgdG8gdmFsaWQga2V5c3BhY2Vcbn1cblxuZnVuY3Rpb24gaW5kZXhUb0xvY2F0aW9uKGluZGV4OiBiaWdpbnQpIHtcbiAgbGV0IGlkeCA9IGluZGV4ICUgTjsgLy8gV3JhcCB0byB2YWxpZCBrZXlzcGFjZVxuICBsZXQgcmVtYWluZGVyID0gaWR4O1xuICBjb25zdCBwYWdlID0gcmVtYWluZGVyICUgUEFHRVM7XG4gIHJlbWFpbmRlciAvPSBQQUdFUztcbiAgY29uc3Qgdm9sdW1lID0gcmVtYWluZGVyICUgVk9MVU1FUztcbiAgcmVtYWluZGVyIC89IFZPTFVNRVM7XG4gIGNvbnN0IHNoZWxmID0gcmVtYWluZGVyICUgU0hFTFZFUztcbiAgcmVtYWluZGVyIC89IFNIRUxWRVM7XG4gIGNvbnN0IHdhbGwgPSByZW1haW5kZXIgJSBXQUxMUztcbiAgcmVtYWluZGVyIC89IFdBTExTO1xuICBjb25zdCBoZXggPSByZW1haW5kZXI7XG4gIHJldHVybiB7XG4gICAgaGV4OiBiaWdJbnRUb0Jhc2UzNihoZXgpLFxuICAgIHdhbGw6IE51bWJlcih3YWxsKSxcbiAgICBzaGVsZjogTnVtYmVyKHNoZWxmKSxcbiAgICB2b2x1bWU6IE51bWJlcih2b2x1bWUpLFxuICAgIHBhZ2U6IE51bWJlcihwYWdlKVxuICB9O1xufVxuXG4vLyBJbXByb3ZlZCBGZWlzdGVsIHJvdW5kIGZ1bmN0aW9uIGZvciBiZXR0ZXIgYml0IG1peGluZ1xuZnVuY3Rpb24gZmVpc3RlbEYocmlnaHQ6IGJpZ2ludCwga2V5OiBiaWdpbnQpOiBiaWdpbnQge1xuICAvLyBNaXggdXNpbmcgYm90aCBtdWx0aXBsaWNhdGlvbiBhbmQgeG9yLCB0aGVuIG1vZCAyXjEyOFxuICByZXR1cm4gKChyaWdodCBeIGtleSkgKiAoa2V5IHwgMW4pICsgKHJpZ2h0IDw8IDEzbikgKyAocmlnaHQgPj4gMTduKSkgJSAoMW4gPDwgMTI4bik7XG59XG5cbmZ1bmN0aW9uIGZlaXN0ZWxFbmNyeXB0KGluZGV4OiBiaWdpbnQpOiBiaWdpbnQge1xuICBsZXQgTCA9IGluZGV4ID4+IDEyOG47XG4gIGxldCBSID0gaW5kZXggJiAoKDFuIDw8IDEyOG4pIC0gMW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IEZFSVNURUxfUk9VTkRTOyArK2kpIHtcbiAgICBjb25zdCBuZXdMID0gUjtcbiAgICBjb25zdCBuZXdSID0gTCBeIGZlaXN0ZWxGKFIsIEZFSVNURUxfS0VZU1tpXSk7XG4gICAgTCA9IG5ld0w7XG4gICAgUiA9IG5ld1I7XG4gIH1cbiAgcmV0dXJuIChMIDw8IDEyOG4pIHwgUjtcbn1cblxuZnVuY3Rpb24gZmVpc3RlbERlY3J5cHQoa2V5OiBiaWdpbnQpOiBiaWdpbnQge1xuICBsZXQgTCA9IGtleSA+PiAxMjhuO1xuICBsZXQgUiA9IGtleSAmICgoMW4gPDwgMTI4bikgLSAxbik7XG4gIGZvciAobGV0IGkgPSBGRUlTVEVMX1JPVU5EUyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3QgbmV3UiA9IEw7XG4gICAgY29uc3QgbmV3TCA9IFIgXiBmZWlzdGVsRihMLCBGRUlTVEVMX0tFWVNbaV0pO1xuICAgIEwgPSBuZXdMO1xuICAgIFIgPSBuZXdSO1xuICB9XG4gIHJldHVybiAoTCA8PCAxMjhuKSB8IFI7XG59XG5cbmZ1bmN0aW9uIGxvY2F0aW9uVG9LZXkoaGV4OiBzdHJpbmcsIHdhbGw6IG51bWJlciwgc2hlbGY6IG51bWJlciwgdm9sdW1lOiBudW1iZXIsIHBhZ2U6IG51bWJlcik6IGJpZ2ludCB7XG4gIGNvbnN0IGluZGV4ID0gbG9jYXRpb25Ub0luZGV4KGhleCwgd2FsbCwgc2hlbGYsIHZvbHVtZSwgcGFnZSk7XG4gIHJldHVybiBmZWlzdGVsRW5jcnlwdChpbmRleCk7XG59XG5cbmZ1bmN0aW9uIGtleVRvTG9jYXRpb24oa2V5OiBiaWdpbnQpIHtcbiAgY29uc3QgaW5kZXggPSBmZWlzdGVsRGVjcnlwdChrZXkpO1xuICByZXR1cm4gaW5kZXhUb0xvY2F0aW9uKGluZGV4KTtcbn1cblxuZnVuY3Rpb24gcHVia2V5VG9QMldQS0gocHVia2V5SGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyAxLiBIYXNoMTYwIChTSEEyNTYgdGhlbiBSSVBFTUQxNjApXG4gIGNvbnN0IHB1YmtleUJ5dGVzID0gdXRpbHMuaGV4VG9CeXRlcyhwdWJrZXlIZXgpO1xuICBjb25zdCBzaGEyNTYgPSB1dGlscy5zaGEyNTYocHVia2V5Qnl0ZXMpO1xuICBjb25zdCByaXBlbWQxNjAgPSB1dGlscy5yaXBlbWQxNjAoc2hhMjU2KTtcbiAgLy8gMi4gV2l0bmVzcyB2ZXJzaW9uIDAgKyBoYXNoMTYwXG4gIGNvbnN0IHdvcmRzID0gYmVjaDMyLnRvV29yZHMocmlwZW1kMTYwKTtcbiAgd29yZHMudW5zaGlmdCgweDAwKTtcbiAgLy8gMy4gRW5jb2RlIGFzIGJlY2gzMiAoYmMxLi4uKVxuICByZXR1cm4gYmVjaDMyLmVuY29kZSgnYmMnLCB3b3Jkcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIC8vIFN0YXRlIGZvciBuYXZpZ2F0aW9uXG4gIGNvbnN0IFtoZXgsIHNldEhleF0gPSB1c2VTdGF0ZSgnMCcpO1xuICBjb25zdCBbd2FsbCwgc2V0V2FsbF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3NoZWxmLCBzZXRTaGVsZl0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3ZvbHVtZSwgc2V0Vm9sdW1lXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbcGFnZSwgc2V0UGFnZV0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2tleUlucHV0LCBzZXRLZXlJbnB1dF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtsb2NhdGlvblJlc3VsdCwgc2V0TG9jYXRpb25SZXN1bHRdID0gdXNlU3RhdGU8UmV0dXJuVHlwZTx0eXBlb2YgaW5kZXhUb0xvY2F0aW9uPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbb3ZlcmZsb3csIHNldE92ZXJmbG93XSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBDb21wdXRlIGluZGV4IGFuZCBvdmVyZmxvd1xuICBjb25zdCBoZXhOdW0gPSBiYXNlMzZUb0JpZ0ludChoZXgpO1xuICBsZXQgaWR4ID0gKCgoKGhleE51bSAqIFdBTExTICsgQmlnSW50KHdhbGwpKSAqIFNIRUxWRVMgKyBCaWdJbnQoc2hlbGYpKSAqIFZPTFVNRVMgKyBCaWdJbnQodm9sdW1lKSkgKiBQQUdFUyArIEJpZ0ludChwYWdlKSk7XG4gIGNvbnN0IGRpZE92ZXJmbG93ID0gaWR4ID49IE47XG4gIGNvbnN0IGtleSA9IGxvY2F0aW9uVG9LZXkoaGV4LCB3YWxsLCBzaGVsZiwgdm9sdW1lLCBwYWdlKTtcblxuICAvLyBDbGFtcCBuYXZpZ2F0aW9uXG4gIGZ1bmN0aW9uIGNsYW1wKHZhbDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5U2VhcmNoKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgayA9IGtleUlucHV0LnN0YXJ0c1dpdGgoJzB4JykgPyBCaWdJbnQoa2V5SW5wdXQpIDogQmlnSW50KCcweCcgKyBrZXlJbnB1dCk7XG4gICAgICBzZXRMb2NhdGlvblJlc3VsdChrZXlUb0xvY2F0aW9uKGspKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHNldExvY2F0aW9uUmVzdWx0KG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUdvVG9Mb2NhdGlvbigpIHtcbiAgICBpZiAobG9jYXRpb25SZXN1bHQpIHtcbiAgICAgIHNldEhleChsb2NhdGlvblJlc3VsdC5oZXgpO1xuICAgICAgc2V0V2FsbChsb2NhdGlvblJlc3VsdC53YWxsKTtcbiAgICAgIHNldFNoZWxmKGxvY2F0aW9uUmVzdWx0LnNoZWxmKTtcbiAgICAgIHNldFZvbHVtZShsb2NhdGlvblJlc3VsdC52b2x1bWUpO1xuICAgICAgc2V0UGFnZShsb2NhdGlvblJlc3VsdC5wYWdlKTtcbiAgICAgIHNldExvY2F0aW9uUmVzdWx0KG51bGwpO1xuICAgICAgc2V0S2V5SW5wdXQoJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmRvbVN0cmluZyhsZW5ndGg6IG51bWJlcikge1xuICAgIGNvbnN0IGNoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBjaGFyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJhbmRvbSgpIHtcbiAgICAvLyBQaWNrIHJhbmRvbSB2YWxpZCB2YWx1ZXMgZm9yIGFsbCBmaWVsZHNcbiAgICBzZXRIZXgocmFuZG9tU3RyaW5nKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDgpICsgMikpOyAvLyAyLTkgY2hhcnNcbiAgICBzZXRXYWxsKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFdBTExTX1BFUl9IRVgpKTtcbiAgICBzZXRTaGVsZihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBTSEVMVkVTX1BFUl9XQUxMKSk7XG4gICAgc2V0Vm9sdW1lKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFZPTFVNRVNfUEVSX1NIRUxGKSk7XG4gICAgc2V0UGFnZShNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBQQUdFU19QRVJfVk9MVU1FKSk7XG4gICAgc2V0TG9jYXRpb25SZXN1bHQobnVsbCk7XG4gICAgc2V0S2V5SW5wdXQoJycpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBwdWJsaWMga2V5IGFuZCBhZGRyZXNzXG4gIGxldCBwdWJrZXlIZXggPSAnJztcbiAgbGV0IGJlY2gzMkFkZHIgPSAnJztcbiAgdHJ5IHtcbiAgICBwdWJrZXlIZXggPSBnZXRQdWJsaWNLZXkoa2V5LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKSwgdHJ1ZSk7IC8vIGNvbXByZXNzZWRcbiAgICBiZWNoMzJBZGRyID0gcHVia2V5VG9QMldQS0gocHVia2V5SGV4KTtcbiAgfSBjYXRjaCB7fVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAyNCwgZm9udEZhbWlseTogJ21vbm9zcGFjZScsIG1heFdpZHRoOiA3MDAsIG1hcmdpbjogJ2F1dG8nIH19PlxuICAgICAgPGgxPkxpYnJhcnkgb2YgUHJpdmF0ZSBLZXlzPC9oMT5cbiAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAxNiB9fT5cbiAgICAgICAgPGI+SGV4YWdvbjo8L2I+IDxpbnB1dCB0eXBlPVwidGV4dFwiIHZhbHVlPXtoZXh9IG9uQ2hhbmdlPXtlID0+IHNldEhleChlLnRhcmdldC52YWx1ZS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpKX0gc3R5bGU9e3sgd2lkdGg6IDkwIH19IC8+XG4gICAgICAgIDxiPiBXYWxsOjwvYj4gPGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IG1heD17V0FMTFNfUEVSX0hFWC0xfSB2YWx1ZT17d2FsbH0gb25DaGFuZ2U9e2UgPT4gc2V0V2FsbChjbGFtcChOdW1iZXIoZS50YXJnZXQudmFsdWUpLCAwLCBXQUxMU19QRVJfSEVYLTEpKX0gLz5cbiAgICAgICAgPGI+IFNoZWxmOjwvYj4gPGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IG1heD17U0hFTFZFU19QRVJfV0FMTC0xfSB2YWx1ZT17c2hlbGZ9IG9uQ2hhbmdlPXtlID0+IHNldFNoZWxmKGNsYW1wKE51bWJlcihlLnRhcmdldC52YWx1ZSksIDAsIFNIRUxWRVNfUEVSX1dBTEwtMSkpfSAvPlxuICAgICAgICA8Yj4gVm9sdW1lOjwvYj4gPGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IG1heD17Vk9MVU1FU19QRVJfU0hFTEYtMX0gdmFsdWU9e3ZvbHVtZX0gb25DaGFuZ2U9e2UgPT4gc2V0Vm9sdW1lKGNsYW1wKE51bWJlcihlLnRhcmdldC52YWx1ZSksIDAsIFZPTFVNRVNfUEVSX1NIRUxGLTEpKX0gLz5cbiAgICAgICAgPGI+IFBhZ2U6PC9iPiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gbWF4PXtQQUdFU19QRVJfVk9MVU1FLTF9IHZhbHVlPXtwYWdlfSBvbkNoYW5nZT17ZSA9PiBzZXRQYWdlKGNsYW1wKE51bWJlcihlLnRhcmdldC52YWx1ZSksIDAsIFBBR0VTX1BFUl9WT0xVTUUtMSkpfSAvPlxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVJhbmRvbX0gc3R5bGU9e3sgbWFyZ2luTGVmdDogMTYgfX0+UmFuZG9tPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIHtkaWRPdmVyZmxvdyAmJiA8ZGl2IHN0eWxlPXt7IGNvbG9yOiAnb3JhbmdlJywgbWFyZ2luQm90dG9tOiA4IH19Pk5vdGU6IFRoaXMgbG9jYXRpb24gaXMgb3V0c2lkZSB0aGUgY2Fub25pY2FsIGtleXNwYWNlIGFuZCB3cmFwcyBhcm91bmQgKHBlcmlvZGljIGxpYnJhcnkpLjwvZGl2Pn1cbiAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luOiAnMjRweCAwJywgYmFja2dyb3VuZDogJyNmNGY0ZjQnLCBwYWRkaW5nOiAxNiwgYm9yZGVyUmFkaXVzOiA4IH19PlxuICAgICAgICA8ZGl2PjxiPlByaXZhdGUgS2V5IChoZXgpOjwvYj48L2Rpdj5cbiAgICAgICAgPGRpdiBzdHlsZT17eyBmb250U2l6ZTogMTgsIHdvcmRCcmVhazogJ2JyZWFrLWFsbCcsIGNvbG9yOiAnIzMzMycgfX0+eycweCcgKyBrZXkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpfTwvZGl2PlxuICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpblRvcDogMTYgfX0+PGI+UHVibGljIEtleSAoaGV4LCBjb21wcmVzc2VkKTo8L2I+PC9kaXY+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFNpemU6IDE1LCB3b3JkQnJlYWs6ICdicmVhay1hbGwnLCBjb2xvcjogJyMyMjInIH19PntwdWJrZXlIZXh9PC9kaXY+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luVG9wOiAxNiB9fT48Yj5CZWNoMzIgQWRkcmVzcyAoUDJXUEtIKTo8L2I+PC9kaXY+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFNpemU6IDE1LCB3b3JkQnJlYWs6ICdicmVhay1hbGwnLCBjb2xvcjogJyMwMDVhMDAnIH19PntiZWNoMzJBZGRyfTwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IHN0eWxlPXt7IGNvbG9yOiAnIzg4OCcsIGZvbnRTaXplOiAxMyB9fT5cbiAgICAgICAgPGRpdj5Mb2NhdGlvbjogSGV4YWdvbiB7aGV4fSwgV2FsbCB7d2FsbH0sIFNoZWxmIHtzaGVsZn0sIFZvbHVtZSB7dm9sdW1lfSwgUGFnZSB7cGFnZX08L2Rpdj5cbiAgICAgICAgPGRpdj5LZXkgSW5kZXg6IHtrZXkudG9TdHJpbmcoKX08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGhyIHN0eWxlPXt7IG1hcmdpbjogJzMycHggMCcgfX0gLz5cbiAgICAgIDxkaXY+XG4gICAgICAgIDxiPkZpbmQgbG9jYXRpb24gYnkga2V5OjwvYj4gPGlucHV0IHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCIweC4uLlwiIHZhbHVlPXtrZXlJbnB1dH0gb25DaGFuZ2U9e2UgPT4gc2V0S2V5SW5wdXQoZS50YXJnZXQudmFsdWUpfSBzdHlsZT17eyB3aWR0aDogMzQwIH19IC8+XG4gICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlS2V5U2VhcmNofSBzdHlsZT17eyBtYXJnaW5MZWZ0OiA4IH19PkZpbmQgTG9jYXRpb248L2J1dHRvbj5cbiAgICAgICAge2xvY2F0aW9uUmVzdWx0ICYmIChcbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpblRvcDogMTIsIGNvbG9yOiAnIzQ0NCcgfX0+XG4gICAgICAgICAgICA8ZGl2PkhleGFnb246IDxiPntsb2NhdGlvblJlc3VsdC5oZXh9PC9iPjwvZGl2PlxuICAgICAgICAgICAgPGRpdj5XYWxsOiA8Yj57bG9jYXRpb25SZXN1bHQud2FsbH08L2I+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2PlNoZWxmOiA8Yj57bG9jYXRpb25SZXN1bHQuc2hlbGZ9PC9iPjwvZGl2PlxuICAgICAgICAgICAgPGRpdj5Wb2x1bWU6IDxiPntsb2NhdGlvblJlc3VsdC52b2x1bWV9PC9iPjwvZGl2PlxuICAgICAgICAgICAgPGRpdj5QYWdlOiA8Yj57bG9jYXRpb25SZXN1bHQucGFnZX08L2I+PC9kaXY+XG4gICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZUdvVG9Mb2NhdGlvbn0gc3R5bGU9e3sgbWFyZ2luVG9wOiA4IH19PkdvIHRvIExvY2F0aW9uPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInV0aWxzIiwiZ2V0UHVibGljS2V5IiwiYmVjaDMyIiwiVk9MVU1FU19QRVJfU0hFTEYiLCJTSEVMVkVTX1BFUl9XQUxMIiwiV0FMTFNfUEVSX0hFWCIsIlBBR0VTX1BFUl9WT0xVTUUiLCJXQUxMUyIsIkJpZ0ludCIsIlNIRUxWRVMiLCJWT0xVTUVTIiwiUEFHRVMiLCJNQVhfS0VZIiwiTiIsIkZFSVNURUxfUk9VTkRTIiwiRkVJU1RFTF9LRVlTIiwiYmFzZTM2VG9CaWdJbnQiLCJzdHIiLCJyZXN1bHQiLCJpIiwibGVuZ3RoIiwiYyIsInRvTG93ZXJDYXNlIiwidiIsImNoYXJDb2RlQXQiLCJiaWdJbnRUb0Jhc2UzNiIsIm51bSIsIm4iLCJyZW0iLCJ0b1N0cmluZyIsImxvY2F0aW9uVG9JbmRleCIsImhleCIsIndhbGwiLCJzaGVsZiIsInZvbHVtZSIsInBhZ2UiLCJoZXhOdW0iLCJpZHgiLCJpbmRleFRvTG9jYXRpb24iLCJpbmRleCIsInJlbWFpbmRlciIsIk51bWJlciIsImZlaXN0ZWxGIiwicmlnaHQiLCJrZXkiLCJmZWlzdGVsRW5jcnlwdCIsIkwiLCJSIiwibmV3TCIsIm5ld1IiLCJmZWlzdGVsRGVjcnlwdCIsImxvY2F0aW9uVG9LZXkiLCJrZXlUb0xvY2F0aW9uIiwicHVia2V5VG9QMldQS0giLCJwdWJrZXlIZXgiLCJwdWJrZXlCeXRlcyIsImhleFRvQnl0ZXMiLCJzaGEyNTYiLCJyaXBlbWQxNjAiLCJ3b3JkcyIsInRvV29yZHMiLCJ1bnNoaWZ0IiwiZW5jb2RlIiwiSG9tZSIsInNldEhleCIsInNldFdhbGwiLCJzZXRTaGVsZiIsInNldFZvbHVtZSIsInNldFBhZ2UiLCJrZXlJbnB1dCIsInNldEtleUlucHV0IiwibG9jYXRpb25SZXN1bHQiLCJzZXRMb2NhdGlvblJlc3VsdCIsIm92ZXJmbG93Iiwic2V0T3ZlcmZsb3ciLCJkaWRPdmVyZmxvdyIsImNsYW1wIiwidmFsIiwibWluIiwibWF4IiwiTWF0aCIsImhhbmRsZUtleVNlYXJjaCIsImsiLCJzdGFydHNXaXRoIiwiaGFuZGxlR29Ub0xvY2F0aW9uIiwicmFuZG9tU3RyaW5nIiwiY2hhcnMiLCJmbG9vciIsInJhbmRvbSIsImhhbmRsZVJhbmRvbSIsImJlY2gzMkFkZHIiLCJwYWRTdGFydCIsImRpdiIsInN0eWxlIiwicGFkZGluZyIsImZvbnRGYW1pbHkiLCJtYXhXaWR0aCIsIm1hcmdpbiIsImgxIiwibWFyZ2luQm90dG9tIiwiYiIsImlucHV0IiwidHlwZSIsInZhbHVlIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0IiwicmVwbGFjZSIsIndpZHRoIiwiYnV0dG9uIiwib25DbGljayIsIm1hcmdpbkxlZnQiLCJjb2xvciIsImJhY2tncm91bmQiLCJib3JkZXJSYWRpdXMiLCJmb250U2l6ZSIsIndvcmRCcmVhayIsIm1hcmdpblRvcCIsImhyIiwicGxhY2Vob2xkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.tsx\n"));

/***/ }),

/***/ "./node_modules/@noble/secp256k1/index.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/secp256k1/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: function() { return /* binding */ CURVE; },\n/* harmony export */   ProjectivePoint: function() { return /* binding */ Point; },\n/* harmony export */   Signature: function() { return /* binding */ Signature; },\n/* harmony export */   etc: function() { return /* binding */ etc; },\n/* harmony export */   getPublicKey: function() { return /* binding */ getPublicKey; },\n/* harmony export */   getSharedSecret: function() { return /* binding */ getSharedSecret; },\n/* harmony export */   sign: function() { return /* binding */ sign; },\n/* harmony export */   signAsync: function() { return /* binding */ signAsync; },\n/* harmony export */   utils: function() { return /* binding */ utils; },\n/* harmony export */   verify: function() { return /* binding */ verify; }\n/* harmony export */ });\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 4KB JS implementation of secp256k1 signatures & ECDH. Compliant with RFC6979.\n * @module\n */\nconst B256 = 2n ** 256n;\nconst P = B256 - 0x1000003d1n; // curve's field prime\nconst N = B256 - 0x14551231950b75fc4402da1732fc9bebfn; // curve (group) order\nconst Gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n; // base point x\nconst Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n; // base point y\n/**\n * secp256k1 curve parameters. Equation is x + ax + b.\n * Gx and Gy are generator coordinates. p is field order, n is group order.\n */\nconst CURVE = {\n    p: P, n: N, a: 0n, b: 7n, Gx, Gy\n}; // exported variables incl. a, b\nconst fLen = 32; // field / group byte length\nconst curve = (x) => M(M(x * x) * x + CURVE.b); // x + ax + b weierstrass formula; a=0\nconst err = (m = '') => { throw new Error(m); }; // error helper, messes-up stack trace\nconst isB = (n) => typeof n === 'bigint'; // is big integer\nconst isS = (s) => typeof s === 'string'; // is string\nconst fe = (n) => isB(n) && 0n < n && n < P; // is field element (invertible)\nconst ge = (n) => isB(n) && 0n < n && n < N; // is group element\nconst isu8 = (a) => (a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array'));\nconst au8 = (a, l) => // assert is Uint8Array (of specific length)\n !isu8(a) || (typeof l === 'number' && l > 0 && a.length !== l) ?\n    err('Uint8Array expected') : a;\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst toU8 = (a, len) => au8(isS(a) ? h2b(a) : u8n(au8(a)), len); // norm(hex/u8a) to u8a\nconst M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n};\nconst aPoint = (p) => (p instanceof Point ? p : err('Point expected')); // is 3d point\n/** Point in 3d xyz projective coordinates. 3d takes less inversions than 2d. */\nclass Point {\n    constructor(px, py, pz) {\n        this.px = px;\n        this.py = py;\n        this.pz = pz;\n        Object.freeze(this);\n    }\n    /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */\n    static fromAffine(p) {\n        return ((p.x === 0n) && (p.y === 0n)) ? I : new Point(p.x, p.y, 1n);\n    }\n    /** Convert Uint8Array or hex string to Point. */\n    static fromHex(hex) {\n        hex = toU8(hex); // convert hex string to Uint8Array\n        let p = undefined;\n        const head = hex[0], tail = hex.subarray(1); // first byte is prefix, rest is data\n        const x = slc(tail, 0, fLen), len = hex.length; // next 32 bytes are x coordinate\n        if (len === 33 && [0x02, 0x03].includes(head)) { // compressed points: 33b, start\n            if (!fe(x))\n                err('Point hex invalid: x not FE'); // with byte 0x02 or 0x03. Check if 0<x<P\n            let y = sqrt(curve(x)); // x + ax + b is right side of equation\n            const isYOdd = (y & 1n) === 1n; // y is equivalent left-side. Calculate y:\n            const headOdd = (head & 1) === 1; // y = y; there are two solutions: y, -y\n            if (headOdd !== isYOdd)\n                y = M(-y); // determine proper solution\n            p = new Point(x, y, 1n); // create point\n        } // Uncompressed points: 65b, start with 0x04\n        if (len === 65 && head === 0x04)\n            p = new Point(x, slc(tail, fLen, 2 * fLen), 1n);\n        return p ? p.ok() : err('Point invalid: not on curve'); // Verify the result\n    }\n    /** Create point from a private key. */\n    static fromPrivateKey(k) { return G.mul(toPriv(k)); }\n    get x() { return this.aff().x; } // .x, .y will call expensive toAffine:\n    get y() { return this.aff().y; } // should be used with care.\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = aPoint(other); // isPoint() checks class equality\n        const X1Z2 = M(X1 * Z2), X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2), Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    /** Flip point over y coordinate. */\n    negate() { return new Point(this.px, M(-this.py), this.pz); }\n    /** Point doubling: P+P, complete formula. */\n    double() { return this.add(this); }\n    /**\n     * Point addition: P+Q, complete, exception-free formula\n     * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).\n     * Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n     */\n    add(other) {\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = aPoint(other);\n        const { a, b } = CURVE;\n        let X3 = 0n, Y3 = 0n, Z3 = 0n;\n        const b3 = M(b * 3n);\n        let t0 = M(X1 * X2), t1 = M(Y1 * Y2), t2 = M(Z1 * Z2), t3 = M(X1 + Y1); // step 1\n        let t4 = M(X2 + Y2); // step 5\n        t3 = M(t3 * t4);\n        t4 = M(t0 + t1);\n        t3 = M(t3 - t4);\n        t4 = M(X1 + Z1);\n        let t5 = M(X2 + Z2); // step 10\n        t4 = M(t4 * t5);\n        t5 = M(t0 + t2);\n        t4 = M(t4 - t5);\n        t5 = M(Y1 + Z1);\n        X3 = M(Y2 + Z2); // step 15\n        t5 = M(t5 * X3);\n        X3 = M(t1 + t2);\n        t5 = M(t5 - X3);\n        Z3 = M(a * t4);\n        X3 = M(b3 * t2); // step 20\n        Z3 = M(X3 + Z3);\n        X3 = M(t1 - Z3);\n        Z3 = M(t1 + Z3);\n        Y3 = M(X3 * Z3);\n        t1 = M(t0 + t0); // step 25\n        t1 = M(t1 + t0);\n        t2 = M(a * t2);\n        t4 = M(b3 * t4);\n        t1 = M(t1 + t2);\n        t2 = M(t0 - t2); // step 30\n        t2 = M(a * t2);\n        t4 = M(t4 + t2);\n        t0 = M(t1 * t4);\n        Y3 = M(Y3 + t0);\n        t0 = M(t5 * t4); // step 35\n        X3 = M(t3 * X3);\n        X3 = M(X3 - t0);\n        t0 = M(t3 * t1);\n        Z3 = M(t5 * Z3);\n        Z3 = M(Z3 + t0); // step 40\n        return new Point(X3, Y3, Z3);\n    }\n    mul(n, safe = true) {\n        if (!safe && n === 0n)\n            return I; // in unsafe mode, allow zero\n        if (!ge(n))\n            err('scalar invalid'); // must be 0 < n < CURVE.n\n        if (this.equals(G))\n            return wNAF(n).p; // use precomputes for base point\n        let p = I, f = G; // init result point & fake point\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) { // double-and-add ladder\n            if (n & 1n)\n                p = p.add(d); // if bit is present, add to point\n            else if (safe)\n                f = f.add(d); // if not, add to fake for timing safety\n        }\n        return p;\n    }\n    mulAddQUns(R, u1, u2) {\n        return this.mul(u1, false).add(R.mul(u2, false)).ok(); // Unsafe: do NOT use for stuff related\n    } // to private keys. Doesn't use Shamir trick\n    /** Convert point to 2d xy affine point. (x, y, z)  (x=x/z, y=y/z) */\n    toAffine() {\n        const { px: x, py: y, pz: z } = this;\n        if (this.equals(I))\n            return { x: 0n, y: 0n }; // fast-path for zero point\n        if (z === 1n)\n            return { x, y }; // if z is 1, pass affine coordinates as-is\n        const iz = inv(z, P); // z^-1: invert z\n        if (M(z * iz) !== 1n)\n            err('inverse invalid'); // (z * z^-1) must be 1, otherwise bad math\n        return { x: M(x * iz), y: M(y * iz) }; // x = x*z^-1; y = y*z^-1\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n        const { x, y } = this.aff(); // convert to 2d xy affine point.\n        if (!fe(x) || !fe(y))\n            err('Point invalid: x or y'); // x and y must be in range 0 < n < P\n        return M(y * y) === curve(x) ? // y = x + ax + b, must be equal\n            this : err('Point invalid: not on curve');\n    }\n    multiply(n) { return this.mul(n); } // Aliases to compress code\n    aff() { return this.toAffine(); }\n    ok() { return this.assertValidity(); }\n    toHex(isCompressed = true) {\n        const { x, y } = this.aff(); // convert to 2d xy affine point\n        const head = isCompressed ? ((y & 1n) === 0n ? '02' : '03') : '04'; // 0x02, 0x03, 0x04 prefix\n        return head + n2h(x) + (isCompressed ? '' : n2h(y)); // prefix||x and ||y\n    }\n    toRawBytes(isCompressed = true) {\n        return h2b(this.toHex(isCompressed)); // re-use toHex(), convert hex to bytes\n    }\n}\n/** Generator / base point */\nPoint.BASE = new Point(Gx, Gy, 1n);\n/** Identity / zero point */\nPoint.ZERO = new Point(0n, 1n, 0n);\nconst { BASE: G, ZERO: I } = Point; // Generator, identity points\nconst padh = (n, pad) => n.toString(16).padStart(pad, '0');\nconst b2h = (b) => Array.from(au8(b)).map(e => padh(e, 2)).join(''); // bytes to hex\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst h2b = (hex) => {\n    const e = 'hex invalid';\n    if (!isS(hex))\n        return err(e);\n    const hl = hex.length, al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) { // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\nconst b2n = (b) => BigInt('0x' + (b2h(b) || '0')); // bytes to number\nconst slc = (b, from, to) => b2n(b.slice(from, to)); // slice bytes num\nconst n2b = (num) => {\n    return isB(num) && num >= 0n && num < B256 ? h2b(padh(num, 2 * fLen)) : err('bigint expected');\n};\nconst n2h = (num) => b2h(n2b(num)); // number to 32b hex\nconst concatB = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + au8(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\nconst inv = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md); // no neg exponent for now\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) { // uses euclidean gcd algorithm\n        const q = b / a, r = b % a; // not constant-time\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst sqrt = (n) => {\n    let r = 1n; // So, a special, fast case. Paper: \"Square Roots from 1;24,51,10 to Dan Shanks\".\n    for (let num = n, e = (P + 1n) / 4n; e > 0n; e >>= 1n) { // powMod: modular exponentiation.\n        if (e & 1n)\n            r = (r * num) % P; // Uses exponentiation by squaring.\n        num = (num * num) % P; // Not constant-time.\n    }\n    return M(r * r) === n ? r : err('sqrt invalid'); // check if result is valid\n};\nconst toPriv = (p) => {\n    if (!isB(p))\n        p = b2n(toU8(p, fLen)); // convert to bigint when bytes\n    return ge(p) ? p : err('private key invalid 3'); // check if bigint is in range\n};\nconst high = (n) => n > (N >> 1n); // if a number is bigger than CURVE.n/2\n/** Creates 33/65-byte public key from 32-byte private key. */\nconst getPublicKey = (privKey, isCompressed = true) => {\n    return Point.fromPrivateKey(privKey).toRawBytes(isCompressed);\n};\n/** ECDSA Signature class. Supports only compact 64-byte representation, not DER. */\nclass Signature {\n    constructor(r, s, recovery) {\n        this.r = r;\n        this.s = s;\n        this.recovery = recovery;\n        this.assertValidity(); // recovery bit is optional when\n    } // constructed outside.\n    /** Create signature from 64b compact (r || s) representation. */\n    static fromCompact(hex) {\n        hex = toU8(hex, 64); // compact repr is (32b r)||(32b s)\n        return new Signature(slc(hex, 0, fLen), slc(hex, fLen, 2 * fLen));\n    }\n    assertValidity() { return ge(this.r) && ge(this.s) ? this : err(); } // 0 < r or s < CURVE.n\n    /** Create new signature, with added recovery bit. */\n    addRecoveryBit(rec) {\n        return new Signature(this.r, this.s, rec);\n    }\n    hasHighS() { return high(this.s); }\n    normalizeS() {\n        return high(this.s) ? new Signature(this.r, M(-this.s, N), this.recovery) : this;\n    }\n    /** ECDSA public key recovery. Requires msg hash and recovery id. */\n    recoverPublicKey(msgh) {\n        const { r, s, recovery: rec } = this; // secg.org/sec1-v2.pdf 4.1.6\n        if (![0, 1, 2, 3].includes(rec))\n            err('recovery id invalid'); // check recovery id\n        const h = bits2int_modN(toU8(msgh, fLen)); // Truncate hash\n        const radj = rec === 2 || rec === 3 ? r + N : r; // If rec was 2 or 3, q.x is bigger than n\n        if (radj >= P)\n            err('q.x invalid'); // ensure q.x is still a field element\n        const head = (rec & 1) === 0 ? '02' : '03'; // head is 0x02 or 0x03\n        const R = Point.fromHex(head + n2h(radj)); // concat head + hex repr of r\n        const ir = inv(radj, N); // r^-1\n        const u1 = M(-h * ir, N); // -hr^-1\n        const u2 = M(s * ir, N); // sr^-1\n        return G.mulAddQUns(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n    }\n    /** Uint8Array 64b compact (r || s) representation. */\n    toCompactRawBytes() { return h2b(this.toCompactHex()); }\n    /** Hex string 64b compact (r || s) representation. */\n    toCompactHex() { return n2h(this.r) + n2h(this.s); }\n}\nconst bits2int = (bytes) => {\n    const delta = bytes.length * 8 - 256; // RFC suggests optional truncating via bits2octets\n    if (delta > 1024)\n        err('msg invalid'); // our CUSTOM check, \"just-in-case\"\n    const num = b2n(bytes); // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which\n    return delta > 0 ? num >> BigInt(delta) : num; // matches bits2int. bits2int can produce res>N.\n};\nconst bits2int_modN = (bytes) => {\n    return M(bits2int(bytes), N); // with 0: BAD for trunc as per RFC vectors\n};\nconst i2o = (num) => n2b(num); // int to octets\nconst cr = () => // We support: 1) browsers 2) node.js 19+ 3) deno, other envs with crypto\n typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\nlet _hmacSync; // Can be redefined by use in utils; built-ins don't provide it\nconst optS = { lowS: true }; // opts for sign()\nconst optV = { lowS: true }; // standard opts for verify()\nconst prepSig = (msgh, priv, opts = optS) => {\n    if (['der', 'recovered', 'canonical'].some(k => k in opts))\n        err('option not supported'); // legacy opts\n    let { lowS } = opts; // generates low-s sigs by default\n    if (lowS == null)\n        lowS = true; // RFC6979 3.2: we skip step A\n    const h1i = bits2int_modN(toU8(msgh)); // msg bigint\n    const h1o = i2o(h1i); // msg octets\n    const d = toPriv(priv); // validate private key, convert to bigint\n    const seed = [i2o(d), h1o]; // Step D of RFC6979 3.2\n    let ent = opts.extraEntropy; // RFC6979 3.6: additional k' (optional)\n    if (ent) // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n        seed.push(ent === true ? etc.randomBytes(fLen) : toU8(ent)); // true == fetch from CSPRNG\n    const m = h1i; // convert msg to bigint\n    const k2sig = (kBytes) => {\n        const k = bits2int(kBytes); // RFC6979 method.\n        if (!ge(k))\n            return; // Check 0 < k < CURVE.n\n        const ik = inv(k, N); // k^-1 mod n, NOT mod P\n        const q = G.mul(k).aff(); // q = Gk\n        const r = M(q.x, N); // r = q.x mod n\n        if (r === 0n)\n            return; // r=0 invalid\n        const s = M(ik * M(m + M(d * r, N), N), N); // s = k^-1(m + rd) mod n\n        if (s === 0n)\n            return; // s=0 invalid\n        let normS = s; // normalized S\n        let rec = (q.x === r ? 0 : 2) | Number(q.y & 1n); // recovery bit\n        if (lowS && high(s)) { // if lowS was passed, ensure s is always\n            normS = M(-s, N); // in the bottom half of CURVE.n\n            rec ^= 1;\n        }\n        return new Signature(r, normS, rec); // use normS, not s\n    };\n    return { seed: concatB(...seed), k2sig };\n};\nfunction hmacDrbg(asynchronous) {\n    let v = u8n(fLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(fLen); // Steps B, C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => { v.fill(1); k.fill(0); i = 0; };\n    const _e = 'drbg: tried 1000 values';\n    if (asynchronous) { // asynchronous=true\n        const h = (...b) => etc.hmacSha256Async(k, v, ...b); // hmac(k)(v, ...values)\n        const reseed = async (seed = u8n()) => {\n            k = await h(u8n([0x00]), seed); // k = hmac(K || V || 0x00 || seed)\n            v = await h(); // v = hmac(K || V)\n            if (seed.length === 0)\n                return;\n            k = await h(u8n([0x01]), seed); // k = hmac(K || V || 0x01 || seed)\n            v = await h(); // v = hmac(K || V)\n        };\n        const gen = async () => {\n            if (i++ >= 1000)\n                err(_e);\n            v = await h(); // v = hmac(K || V)\n            return v;\n        };\n        return async (seed, pred) => {\n            reset(); // the returned fn, don't, it's: 1. slower (JIT). 2. unsafe (async race conditions)\n            await reseed(seed); // Steps D-G\n            let res = undefined; // Step H: grind until k is in [1..n-1]\n            while (!(res = pred(await gen())))\n                await reseed(); // test predicate until it returns ok\n            reset();\n            return res;\n        };\n    }\n    else {\n        const h = (...b) => {\n            const f = _hmacSync;\n            if (!f)\n                err('etc.hmacSha256Sync not set');\n            return f(k, v, ...b); // hmac(k)(v, ...values)\n        };\n        const reseed = (seed = u8n()) => {\n            k = h(u8n([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n            v = h(); // v = hmac(k || v)\n            if (seed.length === 0)\n                return;\n            k = h(u8n([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n            v = h(); // v = hmac(k || v)\n        };\n        const gen = () => {\n            if (i++ >= 1000)\n                err(_e);\n            v = h(); // v = hmac(k || v)\n            return v;\n        };\n        return (seed, pred) => {\n            reset();\n            reseed(seed); // Steps D-G\n            let res = undefined; // Step H: grind until k is in [1..n-1]\n            while (!(res = pred(gen())))\n                reseed(); // test predicate until it returns ok\n            reset();\n            return res;\n        };\n    }\n}\n;\n/** ECDSA signature generation. via secg.org/sec1-v2.pdf 4.1.2 + RFC6979 deterministic k. */\n/**\n * Sign a msg hash using secp256k1. Async.\n * It is advised to use `extraEntropy: true` (from RFC6979 3.6) to prevent fault attacks.\n * Worst case: if randomness source for extraEntropy is bad, it would be as secure as if\n * the option has not been used.\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param priv - private key\n * @param opts - `lowS: true` to prevent malleability (s >= CURVE.n/2), `extraEntropy: boolean | Hex` to improve sig security.\n */\nconst signAsync = async (msgh, priv, opts = optS) => {\n    const { seed, k2sig } = prepSig(msgh, priv, opts); // Extract arguments for hmac-drbg\n    return hmacDrbg(true)(seed, k2sig); // Re-run drbg until k2sig returns ok\n};\n/**\n * Sign a msg hash using secp256k1.\n * It is advised to use `extraEntropy: true` (from RFC6979 3.6) to prevent fault attacks.\n * Worst case: if randomness source for extraEntropy is bad, it would be as secure as if\n * the option has not been used.\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param priv - private key\n * @param opts - `lowS: true` to prevent malleability (s >= CURVE.n/2), `extraEntropy: boolean | Hex` to improve sig security.\n * @example\n * const sig = sign(sha256('hello'), privKey, { extraEntropy: true }).toCompactRawBytes();\n */\nconst sign = (msgh, priv, opts = optS) => {\n    const { seed, k2sig } = prepSig(msgh, priv, opts); // Extract arguments for hmac-drbg\n    return hmacDrbg(false)(seed, k2sig); // Re-run drbg until k2sig returns ok\n};\n/**\n * Verify a signature using secp256k1.\n * @param sig - signature, 64-byte or Signature instance\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param pub - public key\n * @param opts - { lowS: true } is default, prohibits s >= CURVE.n/2 to prevent malleability\n */\nconst verify = (sig, msgh, pub, opts = optV) => {\n    let { lowS } = opts; // ECDSA signature verification\n    if (lowS == null)\n        lowS = true; // Default lowS=true\n    if ('strict' in opts)\n        err('option not supported'); // legacy param\n    let sig_, h, P; // secg.org/sec1-v2.pdf 4.1.4\n    const rs = sig && typeof sig === 'object' && 'r' in sig; // Previous ver supported DER sigs. We\n    if (!rs && (toU8(sig).length !== 2 * fLen)) // throw error when DER is suspected now.\n        err('signature must be 64 bytes');\n    try {\n        sig_ = rs ? new Signature(sig.r, sig.s).assertValidity() : Signature.fromCompact(sig);\n        h = bits2int_modN(toU8(msgh)); // Truncate hash\n        P = pub instanceof Point ? pub.ok() : Point.fromHex(pub); // Validate public key\n    }\n    catch (e) {\n        return false;\n    } // Check sig for validity in both cases\n    if (!sig_)\n        return false;\n    const { r, s } = sig_;\n    if (lowS && high(s))\n        return false; // lowS bans sig.s >= CURVE.n/2\n    let R;\n    try {\n        const is = inv(s, N); // s^-1\n        const u1 = M(h * is, N); // u1 = hs^-1 mod n\n        const u2 = M(r * is, N); // u2 = rs^-1 mod n\n        R = G.mulAddQUns(P, u1, u2).aff(); // R = u1G + u2P\n    }\n    catch (error) {\n        return false;\n    }\n    if (!R)\n        return false; // stop if R is identity / zero point\n    const v = M(R.x, N); // R.x must be in N's field, not P's\n    return v === r; // mod(R.x, n) == r\n};\n/**\n * Elliptic Curve Diffie-Hellman (ECDH) on secp256k1.\n * Result is **NOT hashed**. Use hash on it if you need.\n * @param privA private key A\n * @param pubB public key B\n * @param isCompressed 33-byte or 65-byte output\n * @returns public key C\n */\nconst getSharedSecret = (privA, pubB, isCompressed = true) => {\n    return Point.fromHex(pubB).mul(toPriv(privA)).toRawBytes(isCompressed); // ECDH\n};\nconst hashToPrivateKey = (hash) => {\n    hash = toU8(hash); // produces private keys with modulo bias\n    if (hash.length < fLen + 8 || hash.length > 1024)\n        err('expected 40-1024b'); // being neglible.\n    const num = M(b2n(hash), N - 1n); // takes n+8 bytes\n    return n2b(num + 1n); // returns (hash mod n-1)+1\n};\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    hexToBytes: h2b,\n    bytesToHex: b2h,\n    concatBytes: concatB,\n    bytesToNumberBE: b2n,\n    numberToBytesBE: n2b,\n    mod: M,\n    invert: inv, // math utilities\n    hmacSha256Async: async (key, ...msgs) => {\n        const c = cr(); // async HMAC-SHA256, no sync built-in!\n        const s = c && c.subtle; // For React Native support, see README.\n        if (!s)\n            return err('etc.hmacSha256Async or crypto.subtle must be defined'); // Uses webcrypto built-in cryptography.\n        const k = await s.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n        return u8n(await s.sign('HMAC', k, concatB(...msgs)));\n    },\n    hmacSha256Sync: _hmacSync, // For TypeScript. Actual logic is below\n    hashToPrivateKey: hashToPrivateKey,\n    randomBytes: (len = 32) => {\n        const crypto = cr(); // Must be shimmed in node.js <= 18 to prevent error. See README.\n        if (!crypto || !crypto.getRandomValues)\n            err('crypto.getRandomValues must be defined');\n        return crypto.getRandomValues(u8n(len));\n    },\n};\n/** Curve-specific utilities for private keys. */\nconst utils = {\n    normPrivateKeyToScalar: toPriv,\n    isValidPrivateKey: (key) => { try {\n        return !!toPriv(key);\n    }\n    catch (e) {\n        return false;\n    } },\n    randomPrivateKey: () => hashToPrivateKey(etc.randomBytes(fLen + 16)), // FIPS 186 B.4.1.\n    precompute: (w = 8, p = G) => { p.multiply(3n); w; return p; }, // no-op\n};\nObject.defineProperties(etc, { hmacSha256Sync: {\n        configurable: false, get() { return _hmacSync; }, set(f) { if (!_hmacSync)\n            _hmacSync = f; },\n    } });\nconst W = 8; // Precomputes-related code. W = window size\nconst precompute = () => {\n    const points = []; // 10x sign(), 2x verify(). To achieve this,\n    const windows = 256 / W + 1; // app needs to spend 40ms+ to calculate\n    let p = G, b = p; // a lot of points related to base point G.\n    for (let w = 0; w < windows; w++) { // Points are stored in array and used\n        b = p; // any time Gx multiplication is done.\n        points.push(b); // They consume 16-32 MiB of RAM.\n        for (let i = 1; i < 2 ** (W - 1); i++) {\n            b = b.add(p);\n            points.push(b);\n        }\n        p = b.double(); // Precomputes don't speed-up getSharedKey,\n    } // which multiplies user point by scalar,\n    return points; // when precomputes are using base point\n};\nlet Gpows = undefined; // precomputes for base point G\nconst wNAF = (n) => {\n    // Compared to other point mult methods,\n    const comp = Gpows || (Gpows = precompute()); // stores 2x less points using subtraction\n    const neg = (cnd, p) => { let n = p.negate(); return cnd ? n : p; }; // negate\n    let p = I, f = G; // f must be G, or could become I in the end\n    const windows = 1 + 256 / W; // W=8 17 windows\n    const wsize = 2 ** (W - 1); // W=8 128 window size\n    const mask = BigInt(2 ** W - 1); // W=8 will create mask 0b11111111\n    const maxNum = 2 ** W; // W=8 256\n    const shiftBy = BigInt(W); // W=8 8\n    for (let w = 0; w < windows; w++) {\n        const off = w * wsize;\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > wsize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off1 = off, off2 = off + Math.abs(wbits) - 1; // offsets, evaluate both\n        const cnd1 = w % 2 !== 0, cnd2 = wbits < 0; // conditions, evaluate both\n        if (wbits === 0) {\n            f = f.add(neg(cnd1, comp[off1])); // bits are 0: add garbage to fake point\n        }\n        else { //          ^ can't add off2, off2 = I\n            p = p.add(neg(cnd2, comp[off2])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n}; // !! you can disable precomputes by commenting-out call of the wNAF() inside Point#mul()\n // envs like browser console\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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X05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvc2VjcDI1NmsxL2luZGV4LmpzPzM4OGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLXNlY3AyNTZrMSAtIE1JVCBMaWNlbnNlIChjKSAyMDE5IFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLyoqXG4gKiA0S0IgSlMgaW1wbGVtZW50YXRpb24gb2Ygc2VjcDI1NmsxIHNpZ25hdHVyZXMgJiBFQ0RILiBDb21wbGlhbnQgd2l0aCBSRkM2OTc5LlxuICogQG1vZHVsZVxuICovXG5jb25zdCBCMjU2ID0gMm4gKiogMjU2bjtcbmNvbnN0IFAgPSBCMjU2IC0gMHgxMDAwMDAzZDFuOyAvLyBjdXJ2ZSdzIGZpZWxkIHByaW1lXG5jb25zdCBOID0gQjI1NiAtIDB4MTQ1NTEyMzE5NTBiNzVmYzQ0MDJkYTE3MzJmYzliZWJmbjsgLy8gY3VydmUgKGdyb3VwKSBvcmRlclxuY29uc3QgR3ggPSAweDc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OThuOyAvLyBiYXNlIHBvaW50IHhcbmNvbnN0IEd5ID0gMHg0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4bjsgLy8gYmFzZSBwb2ludCB5XG4vKipcbiAqIHNlY3AyNTZrMSBjdXJ2ZSBwYXJhbWV0ZXJzLiBFcXVhdGlvbiBpcyB4wrMgKyBheCArIGIuXG4gKiBHeCBhbmQgR3kgYXJlIGdlbmVyYXRvciBjb29yZGluYXRlcy4gcCBpcyBmaWVsZCBvcmRlciwgbiBpcyBncm91cCBvcmRlci5cbiAqL1xuY29uc3QgQ1VSVkUgPSB7XG4gICAgcDogUCwgbjogTiwgYTogMG4sIGI6IDduLCBHeCwgR3lcbn07IC8vIGV4cG9ydGVkIHZhcmlhYmxlcyBpbmNsLiBhLCBiXG5jb25zdCBmTGVuID0gMzI7IC8vIGZpZWxkIC8gZ3JvdXAgYnl0ZSBsZW5ndGhcbmNvbnN0IGN1cnZlID0gKHgpID0+IE0oTSh4ICogeCkgKiB4ICsgQ1VSVkUuYik7IC8vIHjCsyArIGF4ICsgYiB3ZWllcnN0cmFzcyBmb3JtdWxhOyBhPTBcbmNvbnN0IGVyciA9IChtID0gJycpID0+IHsgdGhyb3cgbmV3IEVycm9yKG0pOyB9OyAvLyBlcnJvciBoZWxwZXIsIG1lc3Nlcy11cCBzdGFjayB0cmFjZVxuY29uc3QgaXNCID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JzsgLy8gaXMgYmlnIGludGVnZXJcbmNvbnN0IGlzUyA9IChzKSA9PiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7IC8vIGlzIHN0cmluZ1xuY29uc3QgZmUgPSAobikgPT4gaXNCKG4pICYmIDBuIDwgbiAmJiBuIDwgUDsgLy8gaXMgZmllbGQgZWxlbWVudCAoaW52ZXJ0aWJsZSlcbmNvbnN0IGdlID0gKG4pID0+IGlzQihuKSAmJiAwbiA8IG4gJiYgbiA8IE47IC8vIGlzIGdyb3VwIGVsZW1lbnRcbmNvbnN0IGlzdTggPSAoYSkgPT4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbmNvbnN0IGF1OCA9IChhLCBsKSA9PiAvLyBhc3NlcnQgaXMgVWludDhBcnJheSAob2Ygc3BlY2lmaWMgbGVuZ3RoKVxuICFpc3U4KGEpIHx8ICh0eXBlb2YgbCA9PT0gJ251bWJlcicgJiYgbCA+IDAgJiYgYS5sZW5ndGggIT09IGwpID9cbiAgICBlcnIoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKSA6IGE7XG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdG9VOCA9IChhLCBsZW4pID0+IGF1OChpc1MoYSkgPyBoMmIoYSkgOiB1OG4oYXU4KGEpKSwgbGVuKTsgLy8gbm9ybShoZXgvdThhKSB0byB1OGFcbmNvbnN0IE0gPSAoYSwgYiA9IFApID0+IHtcbiAgICBjb25zdCByID0gYSAlIGI7XG4gICAgcmV0dXJuIHIgPj0gMG4gPyByIDogYiArIHI7XG59O1xuY29uc3QgYVBvaW50ID0gKHApID0+IChwIGluc3RhbmNlb2YgUG9pbnQgPyBwIDogZXJyKCdQb2ludCBleHBlY3RlZCcpKTsgLy8gaXMgM2QgcG9pbnRcbi8qKiBQb2ludCBpbiAzZCB4eXogcHJvamVjdGl2ZSBjb29yZGluYXRlcy4gM2QgdGFrZXMgbGVzcyBpbnZlcnNpb25zIHRoYW4gMmQuICovXG5jbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIDNkIHh5eiBwb2ludCBmcm9tIDJkIHh5LiAoMCwgMCkgPT4gKDAsIDEsIDApLCBub3QgKDAsIDAsIDEpICovXG4gICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICByZXR1cm4gKChwLnggPT09IDBuKSAmJiAocC55ID09PSAwbikpID8gSSA6IG5ldyBQb2ludChwLngsIHAueSwgMW4pO1xuICAgIH1cbiAgICAvKiogQ29udmVydCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmcgdG8gUG9pbnQuICovXG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGhleCA9IHRvVTgoaGV4KTsgLy8gY29udmVydCBoZXggc3RyaW5nIHRvIFVpbnQ4QXJyYXlcbiAgICAgICAgbGV0IHAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGhlYWQgPSBoZXhbMF0sIHRhaWwgPSBoZXguc3ViYXJyYXkoMSk7IC8vIGZpcnN0IGJ5dGUgaXMgcHJlZml4LCByZXN0IGlzIGRhdGFcbiAgICAgICAgY29uc3QgeCA9IHNsYyh0YWlsLCAwLCBmTGVuKSwgbGVuID0gaGV4Lmxlbmd0aDsgLy8gbmV4dCAzMiBieXRlcyBhcmUgeCBjb29yZGluYXRlXG4gICAgICAgIGlmIChsZW4gPT09IDMzICYmIFsweDAyLCAweDAzXS5pbmNsdWRlcyhoZWFkKSkgeyAvLyBjb21wcmVzc2VkIHBvaW50czogMzNiLCBzdGFydFxuICAgICAgICAgICAgaWYgKCFmZSh4KSlcbiAgICAgICAgICAgICAgICBlcnIoJ1BvaW50IGhleCBpbnZhbGlkOiB4IG5vdCBGRScpOyAvLyB3aXRoIGJ5dGUgMHgwMiBvciAweDAzLiBDaGVjayBpZiAwPHg8UFxuICAgICAgICAgICAgbGV0IHkgPSBzcXJ0KGN1cnZlKHgpKTsgLy8geMKzICsgYXggKyBiIGlzIHJpZ2h0IHNpZGUgb2YgZXF1YXRpb25cbiAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgMW4pID09PSAxbjsgLy8gecKyIGlzIGVxdWl2YWxlbnQgbGVmdC1zaWRlLiBDYWxjdWxhdGUgecKyOlxuICAgICAgICAgICAgY29uc3QgaGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7IC8vIHkgPSDiiJp5wrI7IHRoZXJlIGFyZSB0d28gc29sdXRpb25zOiB5LCAteVxuICAgICAgICAgICAgaWYgKGhlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICB5ID0gTSgteSk7IC8vIGRldGVybWluZSBwcm9wZXIgc29sdXRpb25cbiAgICAgICAgICAgIHAgPSBuZXcgUG9pbnQoeCwgeSwgMW4pOyAvLyBjcmVhdGUgcG9pbnRcbiAgICAgICAgfSAvLyBVbmNvbXByZXNzZWQgcG9pbnRzOiA2NWIsIHN0YXJ0IHdpdGggMHgwNFxuICAgICAgICBpZiAobGVuID09PSA2NSAmJiBoZWFkID09PSAweDA0KVxuICAgICAgICAgICAgcCA9IG5ldyBQb2ludCh4LCBzbGModGFpbCwgZkxlbiwgMiAqIGZMZW4pLCAxbik7XG4gICAgICAgIHJldHVybiBwID8gcC5vaygpIDogZXJyKCdQb2ludCBpbnZhbGlkOiBub3Qgb24gY3VydmUnKTsgLy8gVmVyaWZ5IHRoZSByZXN1bHRcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBwb2ludCBmcm9tIGEgcHJpdmF0ZSBrZXkuICovXG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KGspIHsgcmV0dXJuIEcubXVsKHRvUHJpdihrKSk7IH1cbiAgICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuYWZmKCkueDsgfSAvLyAueCwgLnkgd2lsbCBjYWxsIGV4cGVuc2l2ZSB0b0FmZmluZTpcbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuYWZmKCkueTsgfSAvLyBzaG91bGQgYmUgdXNlZCB3aXRoIGNhcmUuXG4gICAgLyoqIEVxdWFsaXR5IGNoZWNrOiBjb21wYXJlIHBvaW50cyBQJlEuICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBhUG9pbnQob3RoZXIpOyAvLyBpc1BvaW50KCkgY2hlY2tzIGNsYXNzIGVxdWFsaXR5XG4gICAgICAgIGNvbnN0IFgxWjIgPSBNKFgxICogWjIpLCBYMloxID0gTShYMiAqIFoxKTtcbiAgICAgICAgY29uc3QgWTFaMiA9IE0oWTEgKiBaMiksIFkyWjEgPSBNKFkyICogWjEpO1xuICAgICAgICByZXR1cm4gWDFaMiA9PT0gWDJaMSAmJiBZMVoyID09PSBZMloxO1xuICAgIH1cbiAgICAvKiogRmxpcCBwb2ludCBvdmVyIHkgY29vcmRpbmF0ZS4gKi9cbiAgICBuZWdhdGUoKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgTSgtdGhpcy5weSksIHRoaXMucHopOyB9XG4gICAgLyoqIFBvaW50IGRvdWJsaW5nOiBQK1AsIGNvbXBsZXRlIGZvcm11bGEuICovXG4gICAgZG91YmxlKCkgeyByZXR1cm4gdGhpcy5hZGQodGhpcyk7IH1cbiAgICAvKipcbiAgICAgKiBQb2ludCBhZGRpdGlvbjogUCtRLCBjb21wbGV0ZSwgZXhjZXB0aW9uLWZyZWUgZm9ybXVsYVxuICAgICAqIChSZW5lcy1Db3N0ZWxsby1CYXRpbmEsIGFsZ28gMSBvZiBbMjAxNS8xMDYwXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjApKS5cbiAgICAgKiBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgKi9cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IGFQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCBYMyA9IDBuLCBZMyA9IDBuLCBaMyA9IDBuO1xuICAgICAgICBjb25zdCBiMyA9IE0oYiAqIDNuKTtcbiAgICAgICAgbGV0IHQwID0gTShYMSAqIFgyKSwgdDEgPSBNKFkxICogWTIpLCB0MiA9IE0oWjEgKiBaMiksIHQzID0gTShYMSArIFkxKTsgLy8gc3RlcCAxXG4gICAgICAgIGxldCB0NCA9IE0oWDIgKyBZMik7IC8vIHN0ZXAgNVxuICAgICAgICB0MyA9IE0odDMgKiB0NCk7XG4gICAgICAgIHQ0ID0gTSh0MCArIHQxKTtcbiAgICAgICAgdDMgPSBNKHQzIC0gdDQpO1xuICAgICAgICB0NCA9IE0oWDEgKyBaMSk7XG4gICAgICAgIGxldCB0NSA9IE0oWDIgKyBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgdDQgPSBNKHQ0ICogdDUpO1xuICAgICAgICB0NSA9IE0odDAgKyB0Mik7XG4gICAgICAgIHQ0ID0gTSh0NCAtIHQ1KTtcbiAgICAgICAgdDUgPSBNKFkxICsgWjEpO1xuICAgICAgICBYMyA9IE0oWTIgKyBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgdDUgPSBNKHQ1ICogWDMpO1xuICAgICAgICBYMyA9IE0odDEgKyB0Mik7XG4gICAgICAgIHQ1ID0gTSh0NSAtIFgzKTtcbiAgICAgICAgWjMgPSBNKGEgKiB0NCk7XG4gICAgICAgIFgzID0gTShiMyAqIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICBaMyA9IE0oWDMgKyBaMyk7XG4gICAgICAgIFgzID0gTSh0MSAtIFozKTtcbiAgICAgICAgWjMgPSBNKHQxICsgWjMpO1xuICAgICAgICBZMyA9IE0oWDMgKiBaMyk7XG4gICAgICAgIHQxID0gTSh0MCArIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICB0MSA9IE0odDEgKyB0MCk7XG4gICAgICAgIHQyID0gTShhICogdDIpO1xuICAgICAgICB0NCA9IE0oYjMgKiB0NCk7XG4gICAgICAgIHQxID0gTSh0MSArIHQyKTtcbiAgICAgICAgdDIgPSBNKHQwIC0gdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgIHQyID0gTShhICogdDIpO1xuICAgICAgICB0NCA9IE0odDQgKyB0Mik7XG4gICAgICAgIHQwID0gTSh0MSAqIHQ0KTtcbiAgICAgICAgWTMgPSBNKFkzICsgdDApO1xuICAgICAgICB0MCA9IE0odDUgKiB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgWDMgPSBNKHQzICogWDMpO1xuICAgICAgICBYMyA9IE0oWDMgLSB0MCk7XG4gICAgICAgIHQwID0gTSh0MyAqIHQxKTtcbiAgICAgICAgWjMgPSBNKHQ1ICogWjMpO1xuICAgICAgICBaMyA9IE0oWjMgKyB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgbXVsKG4sIHNhZmUgPSB0cnVlKSB7XG4gICAgICAgIGlmICghc2FmZSAmJiBuID09PSAwbilcbiAgICAgICAgICAgIHJldHVybiBJOyAvLyBpbiB1bnNhZmUgbW9kZSwgYWxsb3cgemVyb1xuICAgICAgICBpZiAoIWdlKG4pKVxuICAgICAgICAgICAgZXJyKCdzY2FsYXIgaW52YWxpZCcpOyAvLyBtdXN0IGJlIDAgPCBuIDwgQ1VSVkUublxuICAgICAgICBpZiAodGhpcy5lcXVhbHMoRykpXG4gICAgICAgICAgICByZXR1cm4gd05BRihuKS5wOyAvLyB1c2UgcHJlY29tcHV0ZXMgZm9yIGJhc2UgcG9pbnRcbiAgICAgICAgbGV0IHAgPSBJLCBmID0gRzsgLy8gaW5pdCByZXN1bHQgcG9pbnQgJiBmYWtlIHBvaW50XG4gICAgICAgIGZvciAobGV0IGQgPSB0aGlzOyBuID4gMG47IGQgPSBkLmRvdWJsZSgpLCBuID4+PSAxbikgeyAvLyBkb3VibGUtYW5kLWFkZCBsYWRkZXJcbiAgICAgICAgICAgIGlmIChuICYgMW4pXG4gICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpOyAvLyBpZiBiaXQgaXMgcHJlc2VudCwgYWRkIHRvIHBvaW50XG4gICAgICAgICAgICBlbHNlIGlmIChzYWZlKVxuICAgICAgICAgICAgICAgIGYgPSBmLmFkZChkKTsgLy8gaWYgbm90LCBhZGQgdG8gZmFrZSBmb3IgdGltaW5nIHNhZmV0eVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBtdWxBZGRRVW5zKFIsIHUxLCB1Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwodTEsIGZhbHNlKS5hZGQoUi5tdWwodTIsIGZhbHNlKSkub2soKTsgLy8gVW5zYWZlOiBkbyBOT1QgdXNlIGZvciBzdHVmZiByZWxhdGVkXG4gICAgfSAvLyB0byBwcml2YXRlIGtleXMuIERvZXNuJ3QgdXNlIFNoYW1pciB0cmlja1xuICAgIC8qKiBDb252ZXJ0IHBvaW50IHRvIDJkIHh5IGFmZmluZSBwb2ludC4gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KSAqL1xuICAgIHRvQWZmaW5lKCkge1xuICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhJKSlcbiAgICAgICAgICAgIHJldHVybiB7IHg6IDBuLCB5OiAwbiB9OyAvLyBmYXN0LXBhdGggZm9yIHplcm8gcG9pbnRcbiAgICAgICAgaWYgKHogPT09IDFuKVxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9OyAvLyBpZiB6IGlzIDEsIHBhc3MgYWZmaW5lIGNvb3JkaW5hdGVzIGFzLWlzXG4gICAgICAgIGNvbnN0IGl6ID0gaW52KHosIFApOyAvLyB6Xi0xOiBpbnZlcnQgelxuICAgICAgICBpZiAoTSh6ICogaXopICE9PSAxbilcbiAgICAgICAgICAgIGVycignaW52ZXJzZSBpbnZhbGlkJyk7IC8vICh6ICogel4tMSkgbXVzdCBiZSAxLCBvdGhlcndpc2UgYmFkIG1hdGhcbiAgICAgICAgcmV0dXJuIHsgeDogTSh4ICogaXopLCB5OiBNKHkgKiBpeikgfTsgLy8geCA9IHgqel4tMTsgeSA9IHkqel4tMVxuICAgIH1cbiAgICAvKiogQ2hlY2tzIGlmIHRoZSBwb2ludCBpcyB2YWxpZCBhbmQgb24tY3VydmUuICovXG4gICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5hZmYoKTsgLy8gY29udmVydCB0byAyZCB4eSBhZmZpbmUgcG9pbnQuXG4gICAgICAgIGlmICghZmUoeCkgfHwgIWZlKHkpKVxuICAgICAgICAgICAgZXJyKCdQb2ludCBpbnZhbGlkOiB4IG9yIHknKTsgLy8geCBhbmQgeSBtdXN0IGJlIGluIHJhbmdlIDAgPCBuIDwgUFxuICAgICAgICByZXR1cm4gTSh5ICogeSkgPT09IGN1cnZlKHgpID8gLy8gecKyID0geMKzICsgYXggKyBiLCBtdXN0IGJlIGVxdWFsXG4gICAgICAgICAgICB0aGlzIDogZXJyKCdQb2ludCBpbnZhbGlkOiBub3Qgb24gY3VydmUnKTtcbiAgICB9XG4gICAgbXVsdGlwbHkobikgeyByZXR1cm4gdGhpcy5tdWwobik7IH0gLy8gQWxpYXNlcyB0byBjb21wcmVzcyBjb2RlXG4gICAgYWZmKCkgeyByZXR1cm4gdGhpcy50b0FmZmluZSgpOyB9XG4gICAgb2soKSB7IHJldHVybiB0aGlzLmFzc2VydFZhbGlkaXR5KCk7IH1cbiAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5hZmYoKTsgLy8gY29udmVydCB0byAyZCB4eSBhZmZpbmUgcG9pbnRcbiAgICAgICAgY29uc3QgaGVhZCA9IGlzQ29tcHJlc3NlZCA/ICgoeSAmIDFuKSA9PT0gMG4gPyAnMDInIDogJzAzJykgOiAnMDQnOyAvLyAweDAyLCAweDAzLCAweDA0IHByZWZpeFxuICAgICAgICByZXR1cm4gaGVhZCArIG4yaCh4KSArIChpc0NvbXByZXNzZWQgPyAnJyA6IG4yaCh5KSk7IC8vIHByZWZpeHx8eCBhbmQgfHx5XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gaDJiKHRoaXMudG9IZXgoaXNDb21wcmVzc2VkKSk7IC8vIHJlLXVzZSB0b0hleCgpLCBjb252ZXJ0IGhleCB0byBieXRlc1xuICAgIH1cbn1cbi8qKiBHZW5lcmF0b3IgLyBiYXNlIHBvaW50ICovXG5Qb2ludC5CQVNFID0gbmV3IFBvaW50KEd4LCBHeSwgMW4pO1xuLyoqIElkZW50aXR5IC8gemVybyBwb2ludCAqL1xuUG9pbnQuWkVSTyA9IG5ldyBQb2ludCgwbiwgMW4sIDBuKTtcbmNvbnN0IHsgQkFTRTogRywgWkVSTzogSSB9ID0gUG9pbnQ7IC8vIEdlbmVyYXRvciwgaWRlbnRpdHkgcG9pbnRzXG5jb25zdCBwYWRoID0gKG4sIHBhZCkgPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQocGFkLCAnMCcpO1xuY29uc3QgYjJoID0gKGIpID0+IEFycmF5LmZyb20oYXU4KGIpKS5tYXAoZSA9PiBwYWRoKGUsIDIpKS5qb2luKCcnKTsgLy8gYnl0ZXMgdG8gaGV4XG5jb25zdCBDID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07IC8vIEFTQ0lJIGNoYXJhY3RlcnNcbmNvbnN0IF9jaCA9IChjaCkgPT4ge1xuICAgIGlmIChjaCA+PSBDLl8wICYmIGNoIDw9IEMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIEMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBDLkEgJiYgY2ggPD0gQy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoQy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBDLmEgJiYgY2ggPD0gQy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoQy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn07XG5jb25zdCBoMmIgPSAoaGV4KSA9PiB7XG4gICAgY29uc3QgZSA9ICdoZXggaW52YWxpZCc7XG4gICAgaWYgKCFpc1MoaGV4KSlcbiAgICAgICAgcmV0dXJuIGVycihlKTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGgsIGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHJldHVybiBlcnIoZSk7XG4gICAgY29uc3QgYXJyYXkgPSB1OG4oYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7IC8vIHRyZWF0IGVhY2ggY2hhciBhcyBBU0NJSVxuICAgICAgICBjb25zdCBuMSA9IF9jaChoZXguY2hhckNvZGVBdChoaSkpOyAvLyBwYXJzZSBmaXJzdCBjaGFyLCBtdWx0aXBseSBpdCBieSAxNlxuICAgICAgICBjb25zdCBuMiA9IF9jaChoZXguY2hhckNvZGVBdChoaSArIDEpKTsgLy8gcGFyc2Ugc2Vjb25kIGNoYXJcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBlcnIoZSk7XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gZXhhbXBsZTogJ0E5JyA9PiAxMCoxNiArIDlcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufTtcbmNvbnN0IGIybiA9IChiKSA9PiBCaWdJbnQoJzB4JyArIChiMmgoYikgfHwgJzAnKSk7IC8vIGJ5dGVzIHRvIG51bWJlclxuY29uc3Qgc2xjID0gKGIsIGZyb20sIHRvKSA9PiBiMm4oYi5zbGljZShmcm9tLCB0bykpOyAvLyBzbGljZSBieXRlcyBudW1cbmNvbnN0IG4yYiA9IChudW0pID0+IHtcbiAgICByZXR1cm4gaXNCKG51bSkgJiYgbnVtID49IDBuICYmIG51bSA8IEIyNTYgPyBoMmIocGFkaChudW0sIDIgKiBmTGVuKSkgOiBlcnIoJ2JpZ2ludCBleHBlY3RlZCcpO1xufTtcbmNvbnN0IG4yaCA9IChudW0pID0+IGIyaChuMmIobnVtKSk7IC8vIG51bWJlciB0byAzMmIgaGV4XG5jb25zdCBjb25jYXRCID0gKC4uLmFycnMpID0+IHtcbiAgICBjb25zdCByID0gdThuKGFycnMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGF1OChhKS5sZW5ndGgsIDApKTsgLy8gY3JlYXRlIHU4YSBvZiBzdW1tZWQgbGVuZ3RoXG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGFycmF5LFxuICAgIGFycnMuZm9yRWFjaChhID0+IHsgci5zZXQoYSwgcGFkKTsgcGFkICs9IGEubGVuZ3RoOyB9KTsgLy8gZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIHJldHVybiByO1xufTtcbmNvbnN0IGludiA9IChudW0sIG1kKSA9PiB7XG4gICAgaWYgKG51bSA9PT0gMG4gfHwgbWQgPD0gMG4pXG4gICAgICAgIGVycignbm8gaW52ZXJzZSBuPScgKyBudW0gKyAnIG1vZD0nICsgbWQpOyAvLyBubyBuZWcgZXhwb25lbnQgZm9yIG5vd1xuICAgIGxldCBhID0gTShudW0sIG1kKSwgYiA9IG1kLCB4ID0gMG4sIHkgPSAxbiwgdSA9IDFuLCB2ID0gMG47XG4gICAgd2hpbGUgKGEgIT09IDBuKSB7IC8vIHVzZXMgZXVjbGlkZWFuIGdjZCBhbGdvcml0aG1cbiAgICAgICAgY29uc3QgcSA9IGIgLyBhLCByID0gYiAlIGE7IC8vIG5vdCBjb25zdGFudC10aW1lXG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHEsIG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIHJldHVybiBiID09PSAxbiA/IE0oeCwgbWQpIDogZXJyKCdubyBpbnZlcnNlJyk7IC8vIGIgaXMgZ2NkIGF0IHRoaXMgcG9pbnRcbn07XG5jb25zdCBzcXJ0ID0gKG4pID0+IHtcbiAgICBsZXQgciA9IDFuOyAvLyBTbywgYSBzcGVjaWFsLCBmYXN0IGNhc2UuIFBhcGVyOiBcIlNxdWFyZSBSb290cyBmcm9tIDE7MjQsNTEsMTAgdG8gRGFuIFNoYW5rc1wiLlxuICAgIGZvciAobGV0IG51bSA9IG4sIGUgPSAoUCArIDFuKSAvIDRuOyBlID4gMG47IGUgPj49IDFuKSB7IC8vIHBvd01vZDogbW9kdWxhciBleHBvbmVudGlhdGlvbi5cbiAgICAgICAgaWYgKGUgJiAxbilcbiAgICAgICAgICAgIHIgPSAociAqIG51bSkgJSBQOyAvLyBVc2VzIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nLlxuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIFA7IC8vIE5vdCBjb25zdGFudC10aW1lLlxuICAgIH1cbiAgICByZXR1cm4gTShyICogcikgPT09IG4gPyByIDogZXJyKCdzcXJ0IGludmFsaWQnKTsgLy8gY2hlY2sgaWYgcmVzdWx0IGlzIHZhbGlkXG59O1xuY29uc3QgdG9Qcml2ID0gKHApID0+IHtcbiAgICBpZiAoIWlzQihwKSlcbiAgICAgICAgcCA9IGIybih0b1U4KHAsIGZMZW4pKTsgLy8gY29udmVydCB0byBiaWdpbnQgd2hlbiBieXRlc1xuICAgIHJldHVybiBnZShwKSA/IHAgOiBlcnIoJ3ByaXZhdGUga2V5IGludmFsaWQgMycpOyAvLyBjaGVjayBpZiBiaWdpbnQgaXMgaW4gcmFuZ2Vcbn07XG5jb25zdCBoaWdoID0gKG4pID0+IG4gPiAoTiA+PiAxbik7IC8vIGlmIGEgbnVtYmVyIGlzIGJpZ2dlciB0aGFuIENVUlZFLm4vMlxuLyoqIENyZWF0ZXMgMzMvNjUtYnl0ZSBwdWJsaWMga2V5IGZyb20gMzItYnl0ZSBwcml2YXRlIGtleS4gKi9cbmNvbnN0IGdldFB1YmxpY0tleSA9IChwcml2S2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSA9PiB7XG4gICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbn07XG4vKiogRUNEU0EgU2lnbmF0dXJlIGNsYXNzLiBTdXBwb3J0cyBvbmx5IGNvbXBhY3QgNjQtYnl0ZSByZXByZXNlbnRhdGlvbiwgbm90IERFUi4gKi9cbmNsYXNzIFNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7IC8vIHJlY292ZXJ5IGJpdCBpcyBvcHRpb25hbCB3aGVuXG4gICAgfSAvLyBjb25zdHJ1Y3RlZCBvdXRzaWRlLlxuICAgIC8qKiBDcmVhdGUgc2lnbmF0dXJlIGZyb20gNjRiIGNvbXBhY3QgKHIgfHwgcykgcmVwcmVzZW50YXRpb24uICovXG4gICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICBoZXggPSB0b1U4KGhleCwgNjQpOyAvLyBjb21wYWN0IHJlcHIgaXMgKDMyYiByKXx8KDMyYiBzKVxuICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGMoaGV4LCAwLCBmTGVuKSwgc2xjKGhleCwgZkxlbiwgMiAqIGZMZW4pKTtcbiAgICB9XG4gICAgYXNzZXJ0VmFsaWRpdHkoKSB7IHJldHVybiBnZSh0aGlzLnIpICYmIGdlKHRoaXMucykgPyB0aGlzIDogZXJyKCk7IH0gLy8gMCA8IHIgb3IgcyA8IENVUlZFLm5cbiAgICAvKiogQ3JlYXRlIG5ldyBzaWduYXR1cmUsIHdpdGggYWRkZWQgcmVjb3ZlcnkgYml0LiAqL1xuICAgIGFkZFJlY292ZXJ5Qml0KHJlYykge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjKTtcbiAgICB9XG4gICAgaGFzSGlnaFMoKSB7IHJldHVybiBoaWdoKHRoaXMucyk7IH1cbiAgICBub3JtYWxpemVTKCkge1xuICAgICAgICByZXR1cm4gaGlnaCh0aGlzLnMpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIE0oLXRoaXMucywgTiksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICB9XG4gICAgLyoqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkuIFJlcXVpcmVzIG1zZyBoYXNoIGFuZCByZWNvdmVyeSBpZC4gKi9cbiAgICByZWNvdmVyUHVibGljS2V5KG1zZ2gpIHtcbiAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzOyAvLyBzZWNnLm9yZy9zZWMxLXYyLnBkZiA0LjEuNlxuICAgICAgICBpZiAoIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgZXJyKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7IC8vIGNoZWNrIHJlY292ZXJ5IGlkXG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKHRvVTgobXNnaCwgZkxlbikpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIE4gOiByOyAvLyBJZiByZWMgd2FzIDIgb3IgMywgcS54IGlzIGJpZ2dlciB0aGFuIG5cbiAgICAgICAgaWYgKHJhZGogPj0gUClcbiAgICAgICAgICAgIGVycigncS54IGludmFsaWQnKTsgLy8gZW5zdXJlIHEueCBpcyBzdGlsbCBhIGZpZWxkIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaGVhZCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnOyAvLyBoZWFkIGlzIDB4MDIgb3IgMHgwM1xuICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChoZWFkICsgbjJoKHJhZGopKTsgLy8gY29uY2F0IGhlYWQgKyBoZXggcmVwciBvZiByXG4gICAgICAgIGNvbnN0IGlyID0gaW52KHJhZGosIE4pOyAvLyByXi0xXG4gICAgICAgIGNvbnN0IHUxID0gTSgtaCAqIGlyLCBOKTsgLy8gLWhyXi0xXG4gICAgICAgIGNvbnN0IHUyID0gTShzICogaXIsIE4pOyAvLyBzcl4tMVxuICAgICAgICByZXR1cm4gRy5tdWxBZGRRVW5zKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgIH1cbiAgICAvKiogVWludDhBcnJheSA2NGIgY29tcGFjdCAociB8fCBzKSByZXByZXNlbnRhdGlvbi4gKi9cbiAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHsgcmV0dXJuIGgyYih0aGlzLnRvQ29tcGFjdEhleCgpKTsgfVxuICAgIC8qKiBIZXggc3RyaW5nIDY0YiBjb21wYWN0IChyIHx8IHMpIHJlcHJlc2VudGF0aW9uLiAqL1xuICAgIHRvQ29tcGFjdEhleCgpIHsgcmV0dXJuIG4yaCh0aGlzLnIpICsgbjJoKHRoaXMucyk7IH1cbn1cbmNvbnN0IGJpdHMyaW50ID0gKGJ5dGVzKSA9PiB7XG4gICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gMjU2OyAvLyBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHNcbiAgICBpZiAoZGVsdGEgPiAxMDI0KVxuICAgICAgICBlcnIoJ21zZyBpbnZhbGlkJyk7IC8vIG91ciBDVVNUT00gY2hlY2ssIFwianVzdC1pbi1jYXNlXCJcbiAgICBjb25zdCBudW0gPSBiMm4oYnl0ZXMpOyAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2hcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07IC8vIG1hdGNoZXMgYml0czJpbnQuIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLlxufTtcbmNvbnN0IGJpdHMyaW50X21vZE4gPSAoYnl0ZXMpID0+IHtcbiAgICByZXR1cm4gTShiaXRzMmludChieXRlcyksIE4pOyAvLyB3aXRoIDA6IEJBRCBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG59O1xuY29uc3QgaTJvID0gKG51bSkgPT4gbjJiKG51bSk7IC8vIGludCB0byBvY3RldHNcbmNvbnN0IGNyID0gKCkgPT4gLy8gV2Ugc3VwcG9ydDogMSkgYnJvd3NlcnMgMikgbm9kZS5qcyAxOSsgMykgZGVubywgb3RoZXIgZW52cyB3aXRoIGNyeXB0b1xuIHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG5sZXQgX2htYWNTeW5jOyAvLyBDYW4gYmUgcmVkZWZpbmVkIGJ5IHVzZSBpbiB1dGlsczsgYnVpbHQtaW5zIGRvbid0IHByb3ZpZGUgaXRcbmNvbnN0IG9wdFMgPSB7IGxvd1M6IHRydWUgfTsgLy8gb3B0cyBmb3Igc2lnbigpXG5jb25zdCBvcHRWID0geyBsb3dTOiB0cnVlIH07IC8vIHN0YW5kYXJkIG9wdHMgZm9yIHZlcmlmeSgpXG5jb25zdCBwcmVwU2lnID0gKG1zZ2gsIHByaXYsIG9wdHMgPSBvcHRTKSA9PiB7XG4gICAgaWYgKFsnZGVyJywgJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKGsgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgZXJyKCdvcHRpb24gbm90IHN1cHBvcnRlZCcpOyAvLyBsZWdhY3kgb3B0c1xuICAgIGxldCB7IGxvd1MgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBXG4gICAgY29uc3QgaDFpID0gYml0czJpbnRfbW9kTih0b1U4KG1zZ2gpKTsgLy8gbXNnIGJpZ2ludFxuICAgIGNvbnN0IGgxbyA9IGkybyhoMWkpOyAvLyBtc2cgb2N0ZXRzXG4gICAgY29uc3QgZCA9IHRvUHJpdihwcml2KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgY29uc3Qgc2VlZCA9IFtpMm8oZCksIGgxb107IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgIGxldCBlbnQgPSBvcHRzLmV4dHJhRW50cm9weTsgLy8gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKVxuICAgIGlmIChlbnQpIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICBzZWVkLnB1c2goZW50ID09PSB0cnVlID8gZXRjLnJhbmRvbUJ5dGVzKGZMZW4pIDogdG9VOChlbnQpKTsgLy8gdHJ1ZSA9PSBmZXRjaCBmcm9tIENTUFJOR1xuICAgIGNvbnN0IG0gPSBoMWk7IC8vIGNvbnZlcnQgbXNnIHRvIGJpZ2ludFxuICAgIGNvbnN0IGsyc2lnID0gKGtCeXRlcykgPT4ge1xuICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gUkZDNjk3OSBtZXRob2QuXG4gICAgICAgIGlmICghZ2UoaykpXG4gICAgICAgICAgICByZXR1cm47IC8vIENoZWNrIDAgPCBrIDwgQ1VSVkUublxuICAgICAgICBjb25zdCBpayA9IGludihrLCBOKTsgLy8ga14tMSBtb2QgbiwgTk9UIG1vZCBQXG4gICAgICAgIGNvbnN0IHEgPSBHLm11bChrKS5hZmYoKTsgLy8gcSA9IEdrXG4gICAgICAgIGNvbnN0IHIgPSBNKHEueCwgTik7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgaWYgKHIgPT09IDBuKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyByPTAgaW52YWxpZFxuICAgICAgICBjb25zdCBzID0gTShpayAqIE0obSArIE0oZCAqIHIsIE4pLCBOKSwgTik7IC8vIHMgPSBrXi0xKG0gKyByZCkgbW9kIG5cbiAgICAgICAgaWYgKHMgPT09IDBuKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBzPTAgaW52YWxpZFxuICAgICAgICBsZXQgbm9ybVMgPSBzOyAvLyBub3JtYWxpemVkIFNcbiAgICAgICAgbGV0IHJlYyA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgMW4pOyAvLyByZWNvdmVyeSBiaXRcbiAgICAgICAgaWYgKGxvd1MgJiYgaGlnaChzKSkgeyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgbm9ybVMgPSBNKC1zLCBOKTsgLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIENVUlZFLm5cbiAgICAgICAgICAgIHJlYyBePSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWMpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgfTtcbiAgICByZXR1cm4geyBzZWVkOiBjb25jYXRCKC4uLnNlZWQpLCBrMnNpZyB9O1xufTtcbmZ1bmN0aW9uIGhtYWNEcmJnKGFzeW5jaHJvbm91cykge1xuICAgIGxldCB2ID0gdThuKGZMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihmTGVuKTsgLy8gU3RlcHMgQiwgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHsgdi5maWxsKDEpOyBrLmZpbGwoMCk7IGkgPSAwOyB9O1xuICAgIGNvbnN0IF9lID0gJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJztcbiAgICBpZiAoYXN5bmNocm9ub3VzKSB7IC8vIGFzeW5jaHJvbm91cz10cnVlXG4gICAgICAgIGNvbnN0IGggPSAoLi4uYikgPT4gZXRjLmhtYWNTaGEyNTZBc3luYyhrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgICAgIGNvbnN0IHJlc2VlZCA9IGFzeW5jIChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgICAgIGsgPSBhd2FpdCBoKHU4bihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoSyB8fCBWIHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgICAgIHYgPSBhd2FpdCBoKCk7IC8vIHYgPSBobWFjKEsgfHwgVilcbiAgICAgICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBrID0gYXdhaXQgaCh1OG4oWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKEsgfHwgViB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgICAgICB2ID0gYXdhaXQgaCgpOyAvLyB2ID0gaG1hYyhLIHx8IFYpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdlbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgICAgICBlcnIoX2UpO1xuICAgICAgICAgICAgdiA9IGF3YWl0IGgoKTsgLy8gdiA9IGhtYWMoSyB8fCBWKVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhc3luYyAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICAgICAgcmVzZXQoKTsgLy8gdGhlIHJldHVybmVkIGZuLCBkb24ndCwgaXQnczogMS4gc2xvd2VyIChKSVQpLiAyLiB1bnNhZmUgKGFzeW5jIHJhY2UgY29uZGl0aW9ucylcbiAgICAgICAgICAgIGF3YWl0IHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoYXdhaXQgZ2VuKCkpKSlcbiAgICAgICAgICAgICAgICBhd2FpdCByZXNlZWQoKTsgLy8gdGVzdCBwcmVkaWNhdGUgdW50aWwgaXQgcmV0dXJucyBva1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBoID0gKC4uLmIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBfaG1hY1N5bmM7XG4gICAgICAgICAgICBpZiAoIWYpXG4gICAgICAgICAgICAgICAgZXJyKCdldGMuaG1hY1NoYTI1NlN5bmMgbm90IHNldCcpO1xuICAgICAgICAgICAgcmV0dXJuIGYoaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgICAgICBrID0gaCh1OG4oWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgayA9IGgodThuKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICAgICAgZXJyKF9lKTtcbiAgICAgICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICAgICAgcmVzZWVkKCk7IC8vIHRlc3QgcHJlZGljYXRlIHVudGlsIGl0IHJldHVybnMgb2tcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cbn1cbjtcbi8qKiBFQ0RTQSBzaWduYXR1cmUgZ2VuZXJhdGlvbi4gdmlhIHNlY2cub3JnL3NlYzEtdjIucGRmIDQuMS4yICsgUkZDNjk3OSBkZXRlcm1pbmlzdGljIGsuICovXG4vKipcbiAqIFNpZ24gYSBtc2cgaGFzaCB1c2luZyBzZWNwMjU2azEuIEFzeW5jLlxuICogSXQgaXMgYWR2aXNlZCB0byB1c2UgYGV4dHJhRW50cm9weTogdHJ1ZWAgKGZyb20gUkZDNjk3OSAzLjYpIHRvIHByZXZlbnQgZmF1bHQgYXR0YWNrcy5cbiAqIFdvcnN0IGNhc2U6IGlmIHJhbmRvbW5lc3Mgc291cmNlIGZvciBleHRyYUVudHJvcHkgaXMgYmFkLCBpdCB3b3VsZCBiZSBhcyBzZWN1cmUgYXMgaWZcbiAqIHRoZSBvcHRpb24gaGFzIG5vdCBiZWVuIHVzZWQuXG4gKiBAcGFyYW0gbXNnaCAtIG1lc3NhZ2UgSEFTSCwgbm90IG1lc3NhZ2UgaXRzZWxmIGUuZy4gc2hhMjU2KG1lc3NhZ2UpXG4gKiBAcGFyYW0gcHJpdiAtIHByaXZhdGUga2V5XG4gKiBAcGFyYW0gb3B0cyAtIGBsb3dTOiB0cnVlYCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eSAocyA+PSBDVVJWRS5uLzIpLCBgZXh0cmFFbnRyb3B5OiBib29sZWFuIHwgSGV4YCB0byBpbXByb3ZlIHNpZyBzZWN1cml0eS5cbiAqL1xuY29uc3Qgc2lnbkFzeW5jID0gYXN5bmMgKG1zZ2gsIHByaXYsIG9wdHMgPSBvcHRTKSA9PiB7XG4gICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2doLCBwcml2LCBvcHRzKTsgLy8gRXh0cmFjdCBhcmd1bWVudHMgZm9yIGhtYWMtZHJiZ1xuICAgIHJldHVybiBobWFjRHJiZyh0cnVlKShzZWVkLCBrMnNpZyk7IC8vIFJlLXJ1biBkcmJnIHVudGlsIGsyc2lnIHJldHVybnMgb2tcbn07XG4vKipcbiAqIFNpZ24gYSBtc2cgaGFzaCB1c2luZyBzZWNwMjU2azEuXG4gKiBJdCBpcyBhZHZpc2VkIHRvIHVzZSBgZXh0cmFFbnRyb3B5OiB0cnVlYCAoZnJvbSBSRkM2OTc5IDMuNikgdG8gcHJldmVudCBmYXVsdCBhdHRhY2tzLlxuICogV29yc3QgY2FzZTogaWYgcmFuZG9tbmVzcyBzb3VyY2UgZm9yIGV4dHJhRW50cm9weSBpcyBiYWQsIGl0IHdvdWxkIGJlIGFzIHNlY3VyZSBhcyBpZlxuICogdGhlIG9wdGlvbiBoYXMgbm90IGJlZW4gdXNlZC5cbiAqIEBwYXJhbSBtc2doIC0gbWVzc2FnZSBIQVNILCBub3QgbWVzc2FnZSBpdHNlbGYgZS5nLiBzaGEyNTYobWVzc2FnZSlcbiAqIEBwYXJhbSBwcml2IC0gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSBvcHRzIC0gYGxvd1M6IHRydWVgIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5IChzID49IENVUlZFLm4vMiksIGBleHRyYUVudHJvcHk6IGJvb2xlYW4gfCBIZXhgIHRvIGltcHJvdmUgc2lnIHNlY3VyaXR5LlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNpZyA9IHNpZ24oc2hhMjU2KCdoZWxsbycpLCBwcml2S2V5LCB7IGV4dHJhRW50cm9weTogdHJ1ZSB9KS50b0NvbXBhY3RSYXdCeXRlcygpO1xuICovXG5jb25zdCBzaWduID0gKG1zZ2gsIHByaXYsIG9wdHMgPSBvcHRTKSA9PiB7XG4gICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2doLCBwcml2LCBvcHRzKTsgLy8gRXh0cmFjdCBhcmd1bWVudHMgZm9yIGhtYWMtZHJiZ1xuICAgIHJldHVybiBobWFjRHJiZyhmYWxzZSkoc2VlZCwgazJzaWcpOyAvLyBSZS1ydW4gZHJiZyB1bnRpbCBrMnNpZyByZXR1cm5zIG9rXG59O1xuLyoqXG4gKiBWZXJpZnkgYSBzaWduYXR1cmUgdXNpbmcgc2VjcDI1NmsxLlxuICogQHBhcmFtIHNpZyAtIHNpZ25hdHVyZSwgNjQtYnl0ZSBvciBTaWduYXR1cmUgaW5zdGFuY2VcbiAqIEBwYXJhbSBtc2doIC0gbWVzc2FnZSBIQVNILCBub3QgbWVzc2FnZSBpdHNlbGYgZS5nLiBzaGEyNTYobWVzc2FnZSlcbiAqIEBwYXJhbSBwdWIgLSBwdWJsaWMga2V5XG4gKiBAcGFyYW0gb3B0cyAtIHsgbG93UzogdHJ1ZSB9IGlzIGRlZmF1bHQsIHByb2hpYml0cyBzID49IENVUlZFLm4vMiB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eVxuICovXG5jb25zdCB2ZXJpZnkgPSAoc2lnLCBtc2doLCBwdWIsIG9wdHMgPSBvcHRWKSA9PiB7XG4gICAgbGV0IHsgbG93UyB9ID0gb3B0czsgLy8gRUNEU0Egc2lnbmF0dXJlIHZlcmlmaWNhdGlvblxuICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgIGxvd1MgPSB0cnVlOyAvLyBEZWZhdWx0IGxvd1M9dHJ1ZVxuICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICBlcnIoJ29wdGlvbiBub3Qgc3VwcG9ydGVkJyk7IC8vIGxlZ2FjeSBwYXJhbVxuICAgIGxldCBzaWdfLCBoLCBQOyAvLyBzZWNnLm9yZy9zZWMxLXYyLnBkZiA0LjEuNFxuICAgIGNvbnN0IHJzID0gc2lnICYmIHR5cGVvZiBzaWcgPT09ICdvYmplY3QnICYmICdyJyBpbiBzaWc7IC8vIFByZXZpb3VzIHZlciBzdXBwb3J0ZWQgREVSIHNpZ3MuIFdlXG4gICAgaWYgKCFycyAmJiAodG9VOChzaWcpLmxlbmd0aCAhPT0gMiAqIGZMZW4pKSAvLyB0aHJvdyBlcnJvciB3aGVuIERFUiBpcyBzdXNwZWN0ZWQgbm93LlxuICAgICAgICBlcnIoJ3NpZ25hdHVyZSBtdXN0IGJlIDY0IGJ5dGVzJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgc2lnXyA9IHJzID8gbmV3IFNpZ25hdHVyZShzaWcuciwgc2lnLnMpLmFzc2VydFZhbGlkaXR5KCkgOiBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2lnKTtcbiAgICAgICAgaCA9IGJpdHMyaW50X21vZE4odG9VOChtc2doKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgUCA9IHB1YiBpbnN0YW5jZW9mIFBvaW50ID8gcHViLm9rKCkgOiBQb2ludC5mcm9tSGV4KHB1Yik7IC8vIFZhbGlkYXRlIHB1YmxpYyBrZXlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgc2lnIGZvciB2YWxpZGl0eSBpbiBib3RoIGNhc2VzXG4gICAgaWYgKCFzaWdfKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeyByLCBzIH0gPSBzaWdfO1xuICAgIGlmIChsb3dTICYmIGhpZ2gocykpXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbG93UyBiYW5zIHNpZy5zID49IENVUlZFLm4vMlxuICAgIGxldCBSO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlzID0gaW52KHMsIE4pOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gTShoICogaXMsIE4pOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gTShyICogaXMsIE4pOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIFIgPSBHLm11bEFkZFFVbnMoUCwgdTEsIHUyKS5hZmYoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIVIpXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gc3RvcCBpZiBSIGlzIGlkZW50aXR5IC8gemVybyBwb2ludFxuICAgIGNvbnN0IHYgPSBNKFIueCwgTik7IC8vIFIueCBtdXN0IGJlIGluIE4ncyBmaWVsZCwgbm90IFAnc1xuICAgIHJldHVybiB2ID09PSByOyAvLyBtb2QoUi54LCBuKSA9PSByXG59O1xuLyoqXG4gKiBFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUtSGVsbG1hbiAoRUNESCkgb24gc2VjcDI1NmsxLlxuICogUmVzdWx0IGlzICoqTk9UIGhhc2hlZCoqLiBVc2UgaGFzaCBvbiBpdCBpZiB5b3UgbmVlZC5cbiAqIEBwYXJhbSBwcml2QSBwcml2YXRlIGtleSBBXG4gKiBAcGFyYW0gcHViQiBwdWJsaWMga2V5IEJcbiAqIEBwYXJhbSBpc0NvbXByZXNzZWQgMzMtYnl0ZSBvciA2NS1ieXRlIG91dHB1dFxuICogQHJldHVybnMgcHVibGljIGtleSBDXG4gKi9cbmNvbnN0IGdldFNoYXJlZFNlY3JldCA9IChwcml2QSwgcHViQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkgPT4ge1xuICAgIHJldHVybiBQb2ludC5mcm9tSGV4KHB1YkIpLm11bCh0b1ByaXYocHJpdkEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7IC8vIEVDREhcbn07XG5jb25zdCBoYXNoVG9Qcml2YXRlS2V5ID0gKGhhc2gpID0+IHtcbiAgICBoYXNoID0gdG9VOChoYXNoKTsgLy8gcHJvZHVjZXMgcHJpdmF0ZSBrZXlzIHdpdGggbW9kdWxvIGJpYXNcbiAgICBpZiAoaGFzaC5sZW5ndGggPCBmTGVuICsgOCB8fCBoYXNoLmxlbmd0aCA+IDEwMjQpXG4gICAgICAgIGVycignZXhwZWN0ZWQgNDAtMTAyNGInKTsgLy8gYmVpbmcgbmVnbGlibGUuXG4gICAgY29uc3QgbnVtID0gTShiMm4oaGFzaCksIE4gLSAxbik7IC8vIHRha2VzIG4rOCBieXRlc1xuICAgIHJldHVybiBuMmIobnVtICsgMW4pOyAvLyByZXR1cm5zIChoYXNoIG1vZCBuLTEpKzFcbn07XG4vKiogTWF0aCwgaGV4LCBieXRlIGhlbHBlcnMuIE5vdCBpbiBgdXRpbHNgIGJlY2F1c2UgdXRpbHMgc2hhcmUgQVBJIHdpdGggbm9ibGUtY3VydmVzLiAqL1xuY29uc3QgZXRjID0ge1xuICAgIGhleFRvQnl0ZXM6IGgyYixcbiAgICBieXRlc1RvSGV4OiBiMmgsXG4gICAgY29uY2F0Qnl0ZXM6IGNvbmNhdEIsXG4gICAgYnl0ZXNUb051bWJlckJFOiBiMm4sXG4gICAgbnVtYmVyVG9CeXRlc0JFOiBuMmIsXG4gICAgbW9kOiBNLFxuICAgIGludmVydDogaW52LCAvLyBtYXRoIHV0aWxpdGllc1xuICAgIGhtYWNTaGEyNTZBc3luYzogYXN5bmMgKGtleSwgLi4ubXNncykgPT4ge1xuICAgICAgICBjb25zdCBjID0gY3IoKTsgLy8gYXN5bmMgSE1BQy1TSEEyNTYsIG5vIHN5bmMgYnVpbHQtaW4hXG4gICAgICAgIGNvbnN0IHMgPSBjICYmIGMuc3VidGxlOyAvLyBGb3IgUmVhY3QgTmF0aXZlIHN1cHBvcnQsIHNlZSBSRUFETUUuXG4gICAgICAgIGlmICghcylcbiAgICAgICAgICAgIHJldHVybiBlcnIoJ2V0Yy5obWFjU2hhMjU2QXN5bmMgb3IgY3J5cHRvLnN1YnRsZSBtdXN0IGJlIGRlZmluZWQnKTsgLy8gVXNlcyB3ZWJjcnlwdG8gYnVpbHQtaW4gY3J5cHRvZ3JhcGh5LlxuICAgICAgICBjb25zdCBrID0gYXdhaXQgcy5pbXBvcnRLZXkoJ3JhdycsIGtleSwgeyBuYW1lOiAnSE1BQycsIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0gfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgcmV0dXJuIHU4bihhd2FpdCBzLnNpZ24oJ0hNQUMnLCBrLCBjb25jYXRCKC4uLm1zZ3MpKSk7XG4gICAgfSxcbiAgICBobWFjU2hhMjU2U3luYzogX2htYWNTeW5jLCAvLyBGb3IgVHlwZVNjcmlwdC4gQWN0dWFsIGxvZ2ljIGlzIGJlbG93XG4gICAgaGFzaFRvUHJpdmF0ZUtleTogaGFzaFRvUHJpdmF0ZUtleSxcbiAgICByYW5kb21CeXRlczogKGxlbiA9IDMyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9IGNyKCk7IC8vIE11c3QgYmUgc2hpbW1lZCBpbiBub2RlLmpzIDw9IDE4IHRvIHByZXZlbnQgZXJyb3IuIFNlZSBSRUFETUUuXG4gICAgICAgIGlmICghY3J5cHRvIHx8ICFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKVxuICAgICAgICAgICAgZXJyKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh1OG4obGVuKSk7XG4gICAgfSxcbn07XG4vKiogQ3VydmUtc3BlY2lmaWMgdXRpbGl0aWVzIGZvciBwcml2YXRlIGtleXMuICovXG5jb25zdCB1dGlscyA9IHtcbiAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiB0b1ByaXYsXG4gICAgaXNWYWxpZFByaXZhdGVLZXk6IChrZXkpID0+IHsgdHJ5IHtcbiAgICAgICAgcmV0dXJuICEhdG9Qcml2KGtleSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IH0sXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gaGFzaFRvUHJpdmF0ZUtleShldGMucmFuZG9tQnl0ZXMoZkxlbiArIDE2KSksIC8vIEZJUFMgMTg2IEIuNC4xLlxuICAgIHByZWNvbXB1dGU6ICh3ID0gOCwgcCA9IEcpID0+IHsgcC5tdWx0aXBseSgzbik7IHc7IHJldHVybiBwOyB9LCAvLyBuby1vcFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGV0YywgeyBobWFjU2hhMjU2U3luYzoge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLCBnZXQoKSB7IHJldHVybiBfaG1hY1N5bmM7IH0sIHNldChmKSB7IGlmICghX2htYWNTeW5jKVxuICAgICAgICAgICAgX2htYWNTeW5jID0gZjsgfSxcbiAgICB9IH0pO1xuY29uc3QgVyA9IDg7IC8vIFByZWNvbXB1dGVzLXJlbGF0ZWQgY29kZS4gVyA9IHdpbmRvdyBzaXplXG5jb25zdCBwcmVjb21wdXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHBvaW50cyA9IFtdOyAvLyAxMHggc2lnbigpLCAyeCB2ZXJpZnkoKS4gVG8gYWNoaWV2ZSB0aGlzLFxuICAgIGNvbnN0IHdpbmRvd3MgPSAyNTYgLyBXICsgMTsgLy8gYXBwIG5lZWRzIHRvIHNwZW5kIDQwbXMrIHRvIGNhbGN1bGF0ZVxuICAgIGxldCBwID0gRywgYiA9IHA7IC8vIGEgbG90IG9mIHBvaW50cyByZWxhdGVkIHRvIGJhc2UgcG9pbnQgRy5cbiAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHdpbmRvd3M7IHcrKykgeyAvLyBQb2ludHMgYXJlIHN0b3JlZCBpbiBhcnJheSBhbmQgdXNlZFxuICAgICAgICBiID0gcDsgLy8gYW55IHRpbWUgR3ggbXVsdGlwbGljYXRpb24gaXMgZG9uZS5cbiAgICAgICAgcG9pbnRzLnB1c2goYik7IC8vIFRoZXkgY29uc3VtZSAxNi0zMiBNaUIgb2YgUkFNLlxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDIgKiogKFcgLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICBiID0gYi5hZGQocCk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChiKTtcbiAgICAgICAgfVxuICAgICAgICBwID0gYi5kb3VibGUoKTsgLy8gUHJlY29tcHV0ZXMgZG9uJ3Qgc3BlZWQtdXAgZ2V0U2hhcmVkS2V5LFxuICAgIH0gLy8gd2hpY2ggbXVsdGlwbGllcyB1c2VyIHBvaW50IGJ5IHNjYWxhcixcbiAgICByZXR1cm4gcG9pbnRzOyAvLyB3aGVuIHByZWNvbXB1dGVzIGFyZSB1c2luZyBiYXNlIHBvaW50XG59O1xubGV0IEdwb3dzID0gdW5kZWZpbmVkOyAvLyBwcmVjb21wdXRlcyBmb3IgYmFzZSBwb2ludCBHXG5jb25zdCB3TkFGID0gKG4pID0+IHtcbiAgICAvLyBDb21wYXJlZCB0byBvdGhlciBwb2ludCBtdWx0IG1ldGhvZHMsXG4gICAgY29uc3QgY29tcCA9IEdwb3dzIHx8IChHcG93cyA9IHByZWNvbXB1dGUoKSk7IC8vIHN0b3JlcyAyeCBsZXNzIHBvaW50cyB1c2luZyBzdWJ0cmFjdGlvblxuICAgIGNvbnN0IG5lZyA9IChjbmQsIHApID0+IHsgbGV0IG4gPSBwLm5lZ2F0ZSgpOyByZXR1cm4gY25kID8gbiA6IHA7IH07IC8vIG5lZ2F0ZVxuICAgIGxldCBwID0gSSwgZiA9IEc7IC8vIGYgbXVzdCBiZSBHLCBvciBjb3VsZCBiZWNvbWUgSSBpbiB0aGUgZW5kXG4gICAgY29uc3Qgd2luZG93cyA9IDEgKyAyNTYgLyBXOyAvLyBXPTggMTcgd2luZG93c1xuICAgIGNvbnN0IHdzaXplID0gMiAqKiAoVyAtIDEpOyAvLyBXPTggMTI4IHdpbmRvdyBzaXplXG4gICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gVz04IHdpbGwgY3JlYXRlIG1hc2sgMGIxMTExMTExMVxuICAgIGNvbnN0IG1heE51bSA9IDIgKiogVzsgLy8gVz04IDI1NlxuICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7IC8vIFc9OCA4XG4gICAgZm9yIChsZXQgdyA9IDA7IHcgPCB3aW5kb3dzOyB3KyspIHtcbiAgICAgICAgY29uc3Qgb2ZmID0gdyAqIHdzaXplO1xuICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spOyAvLyBleHRyYWN0IFcgYml0cy5cbiAgICAgICAgbiA+Pj0gc2hpZnRCeTsgLy8gc2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgaWYgKHdiaXRzID4gd3NpemUpIHtcbiAgICAgICAgICAgIHdiaXRzIC09IG1heE51bTtcbiAgICAgICAgICAgIG4gKz0gMW47XG4gICAgICAgIH0gLy8gc3BsaXQgaWYgYml0cyA+IG1heDogKzIyNCA9PiAyNTYtMzJcbiAgICAgICAgY29uc3Qgb2ZmMSA9IG9mZiwgb2ZmMiA9IG9mZiArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIG9mZnNldHMsIGV2YWx1YXRlIGJvdGhcbiAgICAgICAgY29uc3QgY25kMSA9IHcgJSAyICE9PSAwLCBjbmQyID0gd2JpdHMgPCAwOyAvLyBjb25kaXRpb25zLCBldmFsdWF0ZSBib3RoXG4gICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgZiA9IGYuYWRkKG5lZyhjbmQxLCBjb21wW29mZjFdKSk7IC8vIGJpdHMgYXJlIDA6IGFkZCBnYXJiYWdlIHRvIGZha2UgcG9pbnRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gICAgICAgICAgXiBjYW4ndCBhZGQgb2ZmMiwgb2ZmMiA9IElcbiAgICAgICAgICAgIHAgPSBwLmFkZChuZWcoY25kMiwgY29tcFtvZmYyXSkpOyAvLyBiaXRzIGFyZSAxOiBhZGQgdG8gcmVzdWx0IHBvaW50XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcCwgZiB9OyAvLyByZXR1cm4gYm90aCByZWFsIGFuZCBmYWtlIHBvaW50cyBmb3IgSklUXG59OyAvLyAhISB5b3UgY2FuIGRpc2FibGUgcHJlY29tcHV0ZXMgYnkgY29tbWVudGluZy1vdXQgY2FsbCBvZiB0aGUgd05BRigpIGluc2lkZSBQb2ludCNtdWwoKVxuZXhwb3J0IHsgZ2V0UHVibGljS2V5LCBzaWduLCBzaWduQXN5bmMsIHZlcmlmeSwgQ1VSVkUsIC8vIFJlbW92ZSB0aGUgZXhwb3J0IHRvIGVhc2lseSB1c2UgaW4gUkVQTFxuZ2V0U2hhcmVkU2VjcmV0LCBldGMsIHV0aWxzLCBQb2ludCBhcyBQcm9qZWN0aXZlUG9pbnQsIFNpZ25hdHVyZSB9OyAvLyBlbnZzIGxpa2UgYnJvd3NlciBjb25zb2xlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/secp256k1/index.js\n"));

/***/ })

});